<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Orbit Guardian">
    <meta name="theme-color" content="#000000">
    <title>Orbit Guardian
    </title>
    <link rel="manifest" href="./manifest.json">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <canvas id="bgStars" aria-hidden="true"></canvas>
    
    <!-- GAME HUD OVERLAY -->
    <div id="hud" class="hud-bar">
        <!-- Score Section (Links) -->
        <div class="hud-left">
            <div class="hud-score-main">
                <div class="hud-score-icon">üåü</div>
                <div class="hud-score-content">
                    <div class="hud-score-label">SCORE</div>
                    <div id="score" class="hud-score-value">0</div>
                </div>
            </div>
            <div class="hud-best-main">
                <div class="hud-best-icon">üèÜ</div>
                <div class="hud-best-content">
                    <div class="hud-best-label">BEST</div>
                    <div id="best" class="hud-best-value">0</div>
                </div>
            </div>
        </div>
        
        <!-- Stats Section (Rechts) -->
        <div class="hud-right">
            <div class="chip chip-level"><span class="label">Level</span><span id="levelDisplay" class="value">1</span></div>
            <div class="chip chip-combo hide-mobile"><span class="label">Combo</span><span id="combo" class="value">x1</span></div>
            <div class="chip chip-hp">
                <span class="label">HP</span>
                <span id="hp" class="value">5</span>
                <div id="hpBar" class="hp-bar" aria-hidden="true"><div id="hpFill" class="hp-fill" style="width:100%"></div></div>
            </div>
        </div>
    </div>
    
    <!-- MOBILE HUD TOP BAR -->
    <div id="mobileHudTop" class="mobile-hud-top">
        <div class="mobile-score"><span id="mobileScore">0</span></div>
        <div class="mobile-level"><span id="mobileLevel">Lv 1</span></div>
        <div class="mobile-best"><span id="mobileBest">Best: 0</span></div>
    </div>
    
    <!-- MOBILE INFO PANEL (Challenges, Goals, Galaxy) -->
    <div id="mobileInfoPanel" class="mobile-info-panel" aria-hidden="true">
        <div class="mobile-info-header">
            <h2>üìä STATS</h2>
            <button id="closeMobileInfoBtn" class="close-mobile-info">‚úï</button>
        </div>
        
        <!-- Tab Navigation -->
        <div class="mobile-info-tabs">
            <button class="mobile-info-tab active" data-tab="rank">üèÜ RANG</button>
            <button class="mobile-info-tab" data-tab="session">üìã SESSION</button>
            <button class="mobile-info-tab" data-tab="daily">‚òÄÔ∏è DAILY</button>
            <button class="mobile-info-tab" data-tab="goals">üéØ ZIELE</button>
        </div>
        
        <div class="mobile-info-content">
            <!-- RANK TAB -->
            <div class="mobile-info-section active" id="tab-rank">
                <div class="mobile-galaxy-rank">
                    <div id="mobileRankInfo" class="rank-info">
                        <span class="rank-label">DEIN RANG</span>
                        <span class="rank-value">-</span>
                    </div>
                    <div id="mobileRivalInfo" class="rival-info">
                        <span class="rival-label">DEIN RIVAL</span>
                        <span class="rival-value">-</span>
                    </div>
                </div>
            </div>
            
            <!-- SESSION CHALLENGE TAB -->
            <div class="mobile-info-section" id="tab-session">
                <h3>üìã AKTUELLE SESSION</h3>
                <div id="mobileChallenge" class="mobile-challenge">
                    <div id="mobileChallengeTitle" class="challenge-title">-</div>
                    <div class="challenge-progress">
                        <div id="mobileChallengeFill" class="challenge-fill" style="width:0%"></div>
                    </div>
                    <div id="mobileChallengeText" class="challenge-text">0 / 100</div>
                </div>
            </div>
            
            <!-- DAILY CHALLENGE TAB -->
            <div class="mobile-info-section" id="tab-daily">
                <h3>‚òÄÔ∏è T√ÑGLICHE CHALLENGE</h3>
                <div id="mobileDailyChallenge" class="mobile-daily">-</div>
            </div>
            
            <!-- GOALS TAB -->
            <div class="mobile-info-section" id="tab-goals">
                <h3>üéØ N√ÑCHSTE ZIELE</h3>
                <div id="mobileProgressGoals" class="mobile-goals">-</div>
            </div>
        </div>
    </div>

    <canvas id="c" width="180" height="320"></canvas>
    <div id="tapLayer" class="tap-layer" aria-hidden="true"></div>
    <div id="powerupOverlay" class="powerup-overlay" style="display: none;"></div>

    <div id="controls">
        <button class="ctrBtn" id="dirBtn"> </button>
        <button class="ctrBtn" id="shootBtn">SHOOT</button>
    </div>


    <!-- LEADERBOARD PANEL -->
    <div id="leaderboardPanel" class="leaderboard-panel">
        <div class="leaderboard-header">üèÜ GALAXY RANKS</div>
        <div id="leaderboardList" class="leaderboard-list"></div>
        <div class="leaderboard-rival" id="rivalPanel" style="display:none;">
            <div class="rival-label">‚öîÔ∏è YOUR RIVAL</div>
            <div id="rivalName" class="rival-name">-</div>
            <div id="rivalScore" class="rival-score">0</div>
            <div id="rivalStatus" class="rival-status">-</div>
        </div>
    </div>

    <!-- CHALLENGE PANEL -->
    <div id="challengePanel" class="challenge-panel">
        <div class="challenge-header">üìã SESSION CHALLENGE</div>
        <div id="challengeTitle" class="challenge-title">Destroy 100 Asteroids</div>
        <div class="challenge-progress">
            <div id="challengeBar" class="challenge-bar"><div id="challengeFill" class="challenge-fill" style="width:0%"></div></div>
            <div id="challengeText" class="challenge-text">0 / 100</div>
        </div>
        <div id="challengeReward" class="challenge-reward" style="display:none;">‚ú® COMPLETED!</div>
    </div>

    <!-- DAILY CHALLENGE PANEL -->
    <div id="dailyChallengePanel" class="daily-challenge-panel">
        <div class="daily-header">‚òÄÔ∏è DAILY CHALLENGE</div>
        <div id="dailyChallengeText" class="daily-text">Heute: +20% XP</div>
    </div>

    <!-- PROGRESS GOALS PANEL -->
    <div id="progressGoalsPanel" class="progress-goals-panel">
        <div class="goals-header">üéØ NEXT GOALS</div>
        <div id="progressGoals" class="goals-list"></div>
    </div>

    <!-- START OVERLAY (MAIN MENU) -->
    <div id="overlay" class="start-overlay open" data-start-anywhere="false">
        <!-- Floating asteroids -->
        <div class="asteroid"></div>
        <div class="asteroid"></div>
        <div class="asteroid"></div>
        <div class="asteroid"></div>
        
        <div class="start-panel">
            <div class="start-header">
                <!-- Logo and subtitle hidden for clean startup -->
            </div>
            <div class="start-earth-wrap">
                <img id="earthSprite" class="earth" src="earth.png" alt="Earth" width="64" height="64">
            </div>
            <div class="start-actions">
                <button id="startBtn" class="start-btn">PLAY</button>
                <button id="toggleStatsBtn" class="start-btn ghost-btn">ÔøΩ STATS</button>
            </div>
            
            <!-- START STATS SECTION -->
            <div class="start-stats" id="startStatsPanel" hidden style="display: none;">
                <div class="start-stat-card" id="rankCard" style="cursor: pointer;">
                    <div class="start-stat-icon">üèÜ</div>
                    <div class="start-stat-content">
                        <div class="start-stat-label">DEIN RANG</div>
                        <div id="startRankInfo" class="start-stat-value">-</div>
                    </div>
                </div>
                
                <div class="start-stat-card" id="rivalCard" style="cursor: pointer;">
                    <div class="start-stat-icon">‚öîÔ∏è</div>
                    <div class="start-stat-content">
                        <div class="start-stat-label">RIVAL</div>
                        <div id="startRivalInfo" class="start-stat-value">-</div>
                    </div>
                </div>
                
                <div class="start-stat-card" id="sessionCard" style="cursor: pointer;">
                    <div class="start-stat-icon">üìã</div>
                    <div class="start-stat-content">
                        <div class="start-stat-label">SESSION</div>
                        <div id="startSessionInfo" class="start-stat-value">-</div>
                    </div>
                </div>
                
                <div class="start-stat-card" id="dailyCard" style="cursor: pointer;">
                    <div class="start-stat-icon">‚òÄÔ∏è</div>
                    <div class="start-stat-content">
                        <div class="start-stat-label">DAILY</div>
                        <div id="startDailyInfo" class="start-stat-value">-</div>
                    </div>
                </div>
            </div>
            
            <div class="start-debug" id="startDebug" aria-live="polite" role="status">Bereit</div>
            <div class="overlay-footer">
                <!-- Footer hidden for clean startup -->
            </div>
            <div class="start-footer">
                <div class="tips">Tipp: <kbd>F</kbd> schie√üen ‚Ä¢ <kbd>Q</kbd> Zeitlupe</div>
                <div class="small-row"><button id="settingsBtn" class="ghost">SETTINGS</button></div>
            </div>
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settingsModel" class="settings-model" aria-hidden="true">
        <div class="settings-header">
            <h2>‚öôÔ∏è Einstellungen</h2>
            <button id="closeSettingsBtn" class="close-btn">‚úï</button>
        </div>
        
        <!-- TAB NAVIGATION -->
        <div class="settings-tabs">
            <button class="settings-tab active" data-tab="skins">üé® Skins</button>
            <button class="settings-tab" data-tab="gameplay">üéÆ Gameplay</button>
            <button class="settings-tab" data-tab="audio">üîä Audio</button>
            <button class="settings-tab" data-tab="profile">üìä Profil</button>
        </div>
        
        <!-- SKINS TAB -->
        <div class="settings-content active" data-content="skins">
            <div class="skin-category">
                <h4>üöÄ Schiff-Skin</h4>
                <div id="playerSkinGrid" class="skin-grid"></div>
            </div>
            <div class="skin-category">
                <h4>‚ö° Laser-Skin</h4>
                <div id="laserSkinGrid" class="skin-grid"></div>
            </div>
            <div class="skin-category">
                <h4>üåç Kern-Skin</h4>
                <div id="earthSkinGrid" class="skin-grid"></div>
            </div>
        </div>
        
        <!-- GAMEPLAY TAB -->
        <div class="settings-content" data-content="gameplay">
            <div class="setting-group">
                <h4>üïπÔ∏è Steuerung</h4>
                <label class="setting-option">
                    <input type="radio" name="mode" value="A" checked>
                    <span>Modus A: Tippen = Richtungswechsel</span>
                </label>
                <label class="setting-option">
                    <input type="radio" name="mode" value="B">
                    <span>Modus B: Halten = Richtungswechsel</span>
                </label>
            </div>
            
            <div class="setting-group">
                <h4>üéØ Spielhilfen</h4>
                <label class="setting-option">
                    <input type="checkbox" id="autoShootToggle" checked>
                    <span>Automatisch schie√üen</span>
                </label>
                <label class="setting-option">
                    <input type="checkbox" id="aimAssistToggle" checked disabled>
                    <span>Aim Assist (leichte Zielhilfe)</span>
                </label>
            </div>
        </div>
        
        <!-- AUDIO TAB -->
        <div class="settings-content" data-content="audio">
            <div class="setting-group">
                <h4>üéµ Musik</h4>
                <label class="setting-option">
                    <input type="checkbox" id="musicToggle" checked>
                    <span>Musik aktiviert</span>
                </label>
                <label class="setting-slider">
                    <span>Lautst√§rke</span>
                    <input id="musicVolume" type="range" min="0" max="1" step="0.01" value="0.35">
                    <span id="volumeValue" class="slider-value">35%</span>
                </label>
            </div>
        </div>
        
        <!-- PROFILE TAB -->
        <div class="settings-content" data-content="profile">
            <div class="profile-stats">
                <div class="stat-card">
                    <div class="stat-label">Level</div>
                    <div class="stat-value" id="profileLevel">1</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total XP</div>
                    <div class="stat-value" id="profileXP">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Highscore</div>
                    <div class="stat-value" id="profileHighscore">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Kills</div>
                    <div class="stat-value" id="profileKills">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Bosse besiegt</div>
                    <div class="stat-value" id="profileBosses">0</div>
                </div>
            </div>
            
            <div class="setting-group">
                <h4>üóëÔ∏è Daten zur√ºcksetzen</h4>
                <button id="resetProgressBtn" class="danger-btn">Fortschritt l√∂schen</button>
                <p class="warning-text">‚ö†Ô∏è Alle Levels, XP und Highscores werden gel√∂scht!</p>
            </div>
        </div>
        
        <div class="btnRow">
            <button id="saveSettingsBtn" class="primary-btn">üíæ Speichern</button>
        </div>
    </div>

    <!-- LEADERBOARD MODAL -->
    <div id="leaderboardModal" class="stats-modal" aria-hidden="true">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <h2>üèÜ RANGLISTE</h2>
                <button class="stats-modal-close" id="closeLeaderboard">‚úï</button>
            </div>
            <div class="stats-modal-body">
                <div id="leaderboardTable" class="leaderboard-table"></div>
            </div>
        </div>
    </div>

    <!-- RIVAL MODAL -->
    <div id="rivalModal" class="stats-modal" aria-hidden="true">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <h2>‚öîÔ∏è DEIN RIVAL</h2>
                <button class="stats-modal-close" id="closeRival">‚úï</button>
            </div>
            <div class="stats-modal-body">
                <div id="rivalInfo" class="rival-info"></div>
            </div>
        </div>
    </div>

    <!-- SESSION MODAL -->
    <div id="sessionModal" class="stats-modal" aria-hidden="true">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <h2>üìã SESSION AUFGABEN</h2>
                <button class="stats-modal-close" id="closeSession">‚úï</button>
            </div>
            <div class="stats-modal-body">
                <div id="sessionTasks" class="tasks-list"></div>
            </div>
        </div>
    </div>

    <!-- DAILY MODAL -->
    <div id="dailyModal" class="stats-modal" aria-hidden="true">
        <div class="stats-modal-content">
            <div class="stats-modal-header">
                <h2>‚òÄÔ∏è TAGES-AUFGABEN</h2>
                <button class="stats-modal-close" id="closeDaily">‚úï</button>
            </div>
            <div class="stats-modal-body">
                <div id="dailyTasks" class="tasks-list"></div>
            </div>
        </div>
    </div>

    <script>
// ===== STARS BACKGROUND ANIMATION =====
const bgStarsCanvas = document.getElementById("bgStars");
const bgCtx = bgStarsCanvas ? bgStarsCanvas.getContext("2d") : null;

if (bgStarsCanvas && bgCtx) {
  bgCtx.imageSmoothingEnabled = false;
  
  let stars = [];
  const starCount = 150;
  
  function resizeStarsCanvas() {
    bgStarsCanvas.width = window.innerWidth;
    bgStarsCanvas.height = window.innerHeight;
  }
  
  function initStars() {
    stars = [];
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * bgStarsCanvas.width,
        y: Math.random() * bgStarsCanvas.height,
        size: Math.random() * 2 + 0.5,
        brightness: Math.random() * 0.8 + 0.3,
        vx: (Math.random() - 0.5) * 0.08,
        vy: (Math.random() - 0.5) * 0.08,
      });
    }
  }
  
  function drawStars() {
    bgCtx.fillStyle = "#000000";
    bgCtx.fillRect(0, 0, bgStarsCanvas.width, bgStarsCanvas.height);
    
    for (let star of stars) {
      // Update position (drift)
      star.x += star.vx;
      star.y += star.vy;
      
      // Wrap around
      if (star.x < 0) star.x = bgStarsCanvas.width;
      if (star.x > bgStarsCanvas.width) star.x = 0;
      if (star.y < 0) star.y = bgStarsCanvas.height;
      if (star.y > bgStarsCanvas.height) star.y = 0;
      
      // Subtle flicker
      let flicker = star.brightness + Math.sin(Date.now() * 0.001 + star.x + star.y) * 0.15;
      flicker = Math.max(0.3, Math.min(1, flicker));
      
      bgCtx.fillStyle = `rgba(255, 255, 255, ${flicker})`;
      bgCtx.fillRect(Math.floor(star.x), Math.floor(star.y), star.size, star.size);
    }
  }
  
  resizeStarsCanvas();
  initStars();
  window.addEventListener("resize", resizeStarsCanvas);
  
  let lastStarFrame = 0;
  function animateStars(now) {
    if (now - lastStarFrame > 16) { // ~60fps
      drawStars();
      lastStarFrame = now;
    }
    requestAnimationFrame(animateStars);
  }
  requestAnimationFrame(animateStars);
}

console.log("game.js geladen");
// Global error handler to surface runtime issues in the overlay
window.onerror = function(msg, src, line, col, err){
    console.error('Global error:', msg, src, line, col, err);
    try{
        if (overlay){
            overlay.classList.remove('hidden'); overlay.classList.add('open');
            overlay.querySelector('h1').textContent = 'Fehler';
            overlay.querySelector('p').textContent = String(msg).slice(0,200);
        }
    }catch(e){}
};
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;
ctx.msImageSmoothingEnabled = false;
canvas.style.imageRendering = 'pixelated';
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

const scoreEL = document.getElementById("score");
const bestEL = document.getElementById("best");
const hpEL = document.getElementById("hp");
const hpFill = document.getElementById("hpFill");
const levelDisplay = document.getElementById("levelDisplay");
const overlay = document.getElementById("overlay");
let earthCanvas = null;
function initEarthCanvas(){
    const earthImg = document.getElementById("earthSprite");
    if (!earthImg || earthImg.tagName !== 'IMG') return;
    const c = document.createElement('canvas');
    c.width = c.height = 64;
    const ctx = c.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    earthImg.onload = () => {
        ctx.clearRect(0, 0, 64, 64);
        ctx.drawImage(earthImg, 0, 0, 64, 64);
    };
    if (earthImg.complete) earthImg.onload?.();
    earthCanvas = c;
}
const musicToggle = document.getElementById("musicToggle");
const musicVolumeEl = document.getElementById("musicVolume");
const autoShootToggle = document.getElementById("autoShootToggle");
const aimAssistToggle = document.getElementById("aimAssistToggle");
const shipColorEl = document.getElementById('shipColor');
const earthColorEl = document.getElementById('earthColor');
const laserColorEl = document.getElementById('laserColor');
let masterGain = null;
const settingsBtn = document.getElementById("settingsBtn");
const dirBtn = document.getElementById("dirBtn");
const shootBtn = document.getElementById("shootBtn");
let asteroidSprites = [];
let bossSprite = null;
let bossWarning = null; // { startTime, warningType }
const settingsModel = document.getElementById("settingsModel");
const closeSettingsBtn = document.getElementById("closeSettingsBtn");
const saveSettingsBtn = document.getElementById("saveSettings");
const startBtn = document.getElementById("startBtn");

// Dynamic canvas sizing for mobile
let w, H;

function resizeCanvas() {
    const isMobile = window.innerWidth <= 768;
    if (isMobile) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    } else {
        canvas.width = 360;
        canvas.height = 640;
    }
    w = canvas.width;
    H = canvas.height;
}

resizeCanvas();

let best = Number(localStorage.getItem("best_orbit_guardian") || 0);
bestEL.textContent = best;

// Detect mobile screen size
window.isMobileScreen = window.innerWidth <= 768;
window.addEventListener('resize', () => {
    window.isMobileScreen = window.innerWidth <= 768;
    resizeCanvas();
});

let running = false;
let lastTime = 0;

let score = 0;
let coreMaxHP = 5;
let coreHP = coreMaxHP;

// Combo / Streak
let combo = 1;
let comboTimer = 0;

// === GAMEPLAY MODE ===
let gameplayMode = localStorage.getItem('og_gameplay_mode') || 'A';
let holdDirectionActive = false;
let holdDirectionBase = 1;
let touchHoldActive = false;
const EDGE_ZONE_PX = 80;
let lastTouchTap = 0;
let lastGlobalTap = 0;

function shouldIgnoreGlobalTap(target){
    if (!target || !target.closest) return false;
    return !!target.closest('button, input, select, textarea, a, #settingsModel, .settings-model, #overlay, .start-panel, .start-btn');
}

function getGameplayMode(){
    return document.querySelector('input[name="mode"]:checked')?.value || gameplayMode || 'A';
}

function setGameplayMode(mode){
    gameplayMode = mode || 'A';
    localStorage.setItem('og_gameplay_mode', gameplayMode);
    if (gameplayMode !== 'B') endDirectionHold();
    updateModeUI();
}

function updateModeUI(){
    const tapLayer = document.getElementById('tapLayer');
    if (getGameplayMode() === 'B'){
        if (tapLayer){ tapLayer.classList.remove('is-active'); tapLayer.setAttribute('aria-hidden','true'); }
    } else {
        if (tapLayer){ tapLayer.classList.add('is-active'); tapLayer.setAttribute('aria-hidden','false'); }
    }
}

function startDirectionHold(){
    if (!running || holdDirectionActive) return;
    holdDirectionActive = true;
    holdDirectionBase = orbit.dir;
    orbit.dir = -holdDirectionBase;
    startAudioIfNeeded();
    playBeep();
}

function endDirectionHold(){
    if (!holdDirectionActive) return;
    orbit.dir = holdDirectionBase;
    holdDirectionActive = false;
}

function handleDirectionInputStart(){
    const mode = getGameplayMode();
    if (mode === 'B') startDirectionHold();
    else tap();
}

function handleDirectionInputEnd(){
    const mode = getGameplayMode();
    if (mode === 'B') endDirectionHold();
}

function isEdgeZone(x){
    const w = window.innerWidth || 0;
    return x <= EDGE_ZONE_PX || x >= (w - EDGE_ZONE_PX);
}

// hold timer removed for Mode B (now immediate)

function isAimAssistEnabled(){
    if (aimAssistToggle){
        aimAssistToggle.checked = true;
        aimAssistToggle.disabled = true;
    }
    return true;
}

// === XP & LEVEL SYSTEM ===
let playerXP = Number(localStorage.getItem("og_xp") || 0);
let playerLevel = Number(localStorage.getItem("og_level") || 1);
let totalAsteroidKills = Number(localStorage.getItem("og_total_kills") || 0);

// === MOTIVATIONAL FEEDBACK SYSTEM ===
const FEEDBACK_MESSAGES = {
    common: [
        { de: 'Weiter so!', en: 'Keep going!' },
        { de: 'Guter Schuss!', en: 'Nice shot!' },
        { de: 'Sauber!', en: 'Clean!' },
        { de: 'Treffer.', en: 'Hit.' },
        { de: 'Nice!', en: 'Nice!' },
        { de: 'Konzentriert bleiben.', en: 'Stay focused.' },
        { de: 'Gut reagiert.', en: 'Good reaction.' },
        { de: 'Im Flow.', en: 'In the flow.' },
        { de: 'Stabil.', en: 'Solid.' }
    ],
    uncommon: [
        { de: 'Starker Run.', en: 'Strong run.' },
        { de: 'Du wirst besser.', en: "You're getting better." },
        { de: 'Fast perfekt.', en: 'Almost perfect.' },
        { de: 'Timing sitzt.', en: 'Timing on point.' },
        { de: 'Nice Kontrolle.', en: 'Nice control.' },
        { de: 'Weiter pushen!', en: 'Keep pushing!' },
        { de: 'Sauber gespielt.', en: 'Well played.' },
        { de: 'Gute Entscheidung.', en: 'Good decision.' },
        { de: 'Du lernst schnell.', en: 'You learn fast.' },
        { de: 'Das l√§uft.', en: 'This is working.' }
    ],
    rare: [
        { de: 'Im Tunnel.', en: 'In the zone.' },
        { de: 'Fast unschlagbar.', en: 'Nearly unstoppable.' },
        { de: 'Du liest das Spiel.', en: 'You read the game.' },
        { de: 'Kontrolle √ºbernommen.', en: 'Control established.' },
        { de: 'Perfekter Rhythmus.', en: 'Perfect rhythm.' },
        { de: 'Du dominierst.', en: 'You dominate.' },
        { de: 'Keine Fehler.', en: 'No mistakes.' },
        { de: 'Maschinenmodus.', en: 'Machine mode.' },
        { de: 'Elite-Level.', en: 'Elite level.' },
        { de: 'Das ist stark.', en: "That's strong." }
    ],
    epic: [
        { de: 'Unaufhaltbar.', en: 'Unstoppable.' },
        { de: 'Du kontrollierst das Chaos.', en: 'You control the chaos.' },
        { de: 'Grenzenlos.', en: 'Limitless.' },
        { de: 'Perfekter Lauf.', en: 'Perfect run.' },
        { de: 'Alles passt.', en: 'Everything clicks.' },
        { de: 'Das war krank.', en: 'That was insane.' },
        { de: 'Du tanzt durchs Chaos.', en: 'Dancing through chaos.' },
        { de: 'Absolute Kontrolle.', en: 'Absolute control.' },
        { de: 'Das f√ºhlt sich richtig an.', en: 'This feels right.' },
        { de: 'Du bist im Fokus.', en: 'You are focused.' }
    ],
    legendary: [
        { de: 'Sie haben dich untersch√§tzt.', en: 'They underestimated you.' },
        { de: 'Das System bricht.', en: 'The system breaks.' },
        { de: 'Du bist nicht aufzuhalten.', en: 'You cannot be stopped.' },
        { de: 'Das war vorherbestimmt.', en: 'This was inevitable.' },
        { de: 'Jenseits des Limits.', en: 'Beyond the limit.' },
        { de: 'Niemand kommt hier durch.', en: 'Nothing gets through.' },
        { de: 'Das Universum weicht.', en: 'The universe yields.' },
        { de: 'Du hast es gemeistert.', en: 'You mastered it.' },
        { de: 'Ein perfekter Moment.', en: 'A perfect moment.' },
        { de: 'Legende geboren.', en: 'A legend is born.' }
    ]
};

let legendaryMessagesSeen = JSON.parse(localStorage.getItem('og_legendary_msgs') || '[]');
let lastFeedbackTime = 0;

function showFeedback(rarity){
    const now = Date.now();
    if (now - lastFeedbackTime < 300) return; // Reduziert auf 300ms
    lastFeedbackTime = now;
    
    const messages = FEEDBACK_MESSAGES[rarity];
    if (!messages || messages.length === 0){
        console.error(`No messages for rarity: ${rarity}`);
        return;
    }
    const msg = messages[Math.floor(Math.random() * messages.length)];
    
    // Track legendary messages
    if (rarity === 'legendary' && !legendaryMessagesSeen.includes(msg.de)){
        legendaryMessagesSeen.push(msg.de);
        localStorage.setItem('og_legendary_msgs', JSON.stringify(legendaryMessagesSeen));
    }
    
    const feedback = document.createElement('div');
    feedback.className = `feedback-message feedback-${rarity}`;
    feedback.textContent = msg.de;
    feedback.style.zIndex = '9999'; // Ensure it's visible
    feedback.style.position = 'fixed';
    feedback.style.top = '50%';
    feedback.style.left = '50%';
    feedback.style.transform = 'translate(-50%, -50%)';
    document.body.appendChild(feedback);
    
    console.log(`[FEEDBACK ${rarity}] ${msg.de} | Combo: ${combo}`); // Debug
    
    // Animation based on rarity
    if (rarity === 'rare'){
        screenShake = Math.max(screenShake, 8);
    } else if (rarity === 'epic'){
        screenShake = Math.max(screenShake, 15);
        timeScale = 0.2;
        setTimeout(() => { timeScale = 1; }, 200);
    } else if (rarity === 'legendary'){
        screenShake = Math.max(screenShake, 20);
        timeScale = 0;
        setTimeout(() => { timeScale = 1; }, 400);
    }
    
    setTimeout(() => feedback.remove(), rarity === 'legendary' ? 4000 : 3000);
}

function triggerFeedback(){
    // ALWAYS trigger on first 3 kills for testing
    if (combo >= 2){
        const rand = Math.random();
        if (rand < 0.50) showFeedback('common'); // 50% - very common
        else if (rand < 0.70) showFeedback('uncommon'); // 20%
        else if (rand < 0.85) showFeedback('rare'); // 15%
        else if (rand < 0.95) showFeedback('epic'); // 10%
        else showFeedback('legendary'); // 5% (for testing)
    }
}

// === DAILY CHALLENGE SYSTEM ===
let dailyChallenge = null;

function getDailyChallenge(){
    const today = new Date().toDateString();
    const saved = localStorage.getItem('og_daily_challenge');
    if (saved){
        const data = JSON.parse(saved);
        if (data.date === today) return data.challenge;
    }
    
    // Generate new daily challenge
    const challenges = [
        { type: 'xp_boost', name: 'Heute: +20% XP', bonus: 1.2 },
        { type: 'kill_goal', name: 'Zerst√∂re 50 Asteroiden', goal: 50, progress: 0 },
        { type: 'score_goal', name: 'Erreiche 5000 Punkte', goal: 5000, progress: 0 }
    ];
    
    const challenge = challenges[Math.floor(Math.random() * challenges.length)];
    localStorage.setItem('og_daily_challenge', JSON.stringify({ date: today, challenge }));
    return challenge;
}

dailyChallenge = getDailyChallenge();

// === PROGRESS GOALS SYSTEM ===
function getNextGoals(){
    const goals = [];
    const xpNeeded = getXPForLevel(playerLevel);
    const xpRemaining = xpNeeded - playerXP;
    goals.push(`Noch ${xpRemaining} XP bis Level ${playerLevel + 1}`);
    
    // Next skin unlock
    const allSkins = [...SKINS.player, ...SKINS.laser, ...SKINS.earth];
    const nextSkin = allSkins.find(s => !s.unlocked && s.unlockLevel > playerLevel);
    if (nextSkin){
        goals.push(`Noch ${nextSkin.unlockLevel - playerLevel} Level bis ${nextSkin.name}`);
    }
    
    return goals;
}

function updateGoalsUI(){
    const goalsEl = document.getElementById('progressGoals');
    if (!goalsEl) return;
    const goals = getNextGoals();
    goalsEl.innerHTML = goals.map(g => `<div class="goal-item">üéØ ${g}</div>`).join('');
}

function updateDailyChallengeUI(){
    const dailyEl = document.getElementById('dailyChallengeText');
    if (!dailyEl || !dailyChallenge) return;
    
    if (dailyChallenge.type === 'xp_boost'){
        dailyEl.textContent = dailyChallenge.name;
    } else if (dailyChallenge.type === 'kill_goal'){
        const progress = dailyChallenge.progress || 0;
        dailyEl.textContent = `${dailyChallenge.name} (${progress}/${dailyChallenge.goal})`;
    } else if (dailyChallenge.type === 'score_goal'){
        const progress = Math.floor(score);
        dailyEl.textContent = `${dailyChallenge.name} (${progress}/${dailyChallenge.goal})`;
    }
}

function getXPForLevel(level){
    return Math.floor(100 * Math.pow(1.5, level - 1)); // Exponential scaling
}

function addXP(amount){
    playerXP += amount;
    const xpNeeded = getXPForLevel(playerLevel);
    
    if (playerXP >= xpNeeded){
        playerXP -= xpNeeded;
        playerLevel++;
        localStorage.setItem("og_level", String(playerLevel));
        showLevelUpNotification();
    }
    
    localStorage.setItem("og_xp", String(playerXP));
    updateXPUI();
}

function updateXPUI(){
    const xpEl = document.getElementById('xpBar');
    const levelEl = document.getElementById('levelText');
    if (xpEl && levelEl){
        const xpNeeded = getXPForLevel(playerLevel);
        const percent = (playerXP / xpNeeded) * 100;
        xpEl.style.width = `${percent}%`;
        levelEl.textContent = `Level ${playerLevel}`;
    }
}

function showLevelUpNotification(){
    const notif = document.createElement('div');
    notif.className = 'level-up-notification';
    notif.innerHTML = `
        <div class="level-up-text">üéâ LEVEL UP!</div>
        <div class="level-up-number">Level ${playerLevel}</div>
    `;
    document.body.appendChild(notif);
    setTimeout(() => notif.remove(), 3000);
}

// === SKIN SYSTEM ===
const SKINS = {
    player: [
        { id: 'classic', name: '‚ö™ CLASSIC', color: '#ffffff', unlockLevel: 1, unlocked: true },
        { id: 'azure', name: 'üîµ AZURE', color: '#4a9eff', unlockLevel: 3 },
        { id: 'emerald', name: 'üü¢ EMERALD', color: '#4ade80', unlockLevel: 6 },
        { id: 'inferno', name: 'üî¥ INFERNO', color: '#ff4444', unlockLevel: 10 },
        { id: 'neon', name: 'üü° NEON', color: '#ffd580', unlockLevel: 15 },
        { id: 'void', name: 'üü£ VOID', color: '#a78bfa', unlockLevel: 25 }
    ],
    laser: [
        { id: 'standard', name: 'Standard', color: '#ffd580', unlockLevel: 1, unlocked: true },
        { id: 'plasma', name: 'Plasma', color: '#4ade80', unlockLevel: 5 },
        { id: 'flame', name: 'Flame', color: '#ff6644', unlockLevel: 8 },
        { id: 'cyber', name: 'Cyber', color: '#00ffff', unlockLevel: 12 },
        { id: 'void', name: 'Void', color: '#a78bfa', unlockLevel: 20 }
    ],
    earth: [
        { id: 'earth', name: 'üåç Earth', color: '#2e8bff', unlockLevel: 1, unlocked: true },
        { id: 'ice', name: '‚ùÑÔ∏è Ice Planet', color: '#88ccff', unlockLevel: 30 },
        { id: 'lava', name: 'üåã Lava Core', color: '#ff4422', unlockLevel: 40 },
        { id: 'tech', name: '‚öôÔ∏è Tech Core', color: '#00ffaa', unlockLevel: 50 }
    ]
};

let activeSkins = {
    player: localStorage.getItem('og_skin_player') || 'classic',
    laser: localStorage.getItem('og_skin_laser') || 'standard',
    earth: localStorage.getItem('og_skin_earth') || 'earth'
};

function unlockSkins(){
    let anyUnlocked = false;
    Object.keys(SKINS).forEach(category => {
        SKINS[category].forEach(skin => {
            if (!skin.unlocked && playerLevel >= skin.unlockLevel){
                skin.unlocked = true;
                anyUnlocked = true;
            }
        });
    });
    if (anyUnlocked) renderSkinMenu();
}

function getActiveSkin(category){
    return SKINS[category].find(s => s.id === activeSkins[category]) || SKINS[category][0];
}

function setSkin(category, skinId){
    activeSkins[category] = skinId;
    localStorage.setItem(`og_skin_${category}`, skinId);
    renderSkinMenu();
}

// === LEADERBOARD & RIVAL SYSTEM ===
const botNames = [
    "Nova_07", "VoidRunner", "AstraX", "CosmicAce", "StarBlade", "NebulaPro",
    "OrbitKing", "GalaxyFox", "QuantumShot", "SolarFlare", "DarkMatter99",
    "PhoenixWing", "CometStrike", "LunarEcho", "VortexPilot", "PlasmaBurst",
    "CelestialX", "HyperDrift", "AstroNinja", "MeteorSlayer", "TitanGuard",
    "VoidHunter", "StarCrusher", "NebulaX", "CosmicRage", "OrbitDemon",
    "GalaxyGhost", "QuantumBlitz", "SolarWind", "DarkEnergy", "PhoenixX",
    "CometRider", "LunarPhantom", "VortexStrike", "PlasmaX", "CelestialFury",
    "HyperNova", "AstroWolf", "MeteorKnight", "TitanX", "VoidAssassin"
];

let leaderboard = [];
let playerRank = 0;
let rivalBot = null;
let sessionChallenge = null;
let challengeProgress = 0;

function initLeaderboard(){
    const savedBoard = localStorage.getItem('og_leaderboard');
    if (savedBoard){
        leaderboard = JSON.parse(savedBoard);
        // Remove old player entry to re-add with current highscore
        leaderboard = leaderboard.filter(e => e.isBot);
    } else {
        // Generate 40 bots with random scores
        leaderboard = [];
        for (let i = 0; i < 40; i++){
            const botName = botNames[i % botNames.length] + (i > botNames.length ? `_${i}` : '');
            const baseScore = Math.floor(Math.random() * 5000) + 500;
            leaderboard.push({
                name: botName,
                score: baseScore,
                isBot: true,
                style: ['Aggressive', 'Defensive', 'Risky'][Math.floor(Math.random() * 3)]
            });
        }
    }
    
    // Always add player with current best score
    if (best > 0){
        leaderboard.push({ name: 'YOU', score: best, isBot: false });
    }
    
    // Sort by score to ensure correct placement
    leaderboard.sort((a, b) => b.score - a.score);
    saveLeaderboard();
    
    // Show leaderboard immediately
    if (leaderboardPanel){
        leaderboardPanel.style.display = 'block';
        leaderboardPanel.style.visibility = 'visible';
    }
    renderLeaderboard();
}

function saveLeaderboard(){
    localStorage.setItem('og_leaderboard', JSON.stringify(leaderboard));
}

function updateLeaderboard(){
    // Remove player entry to re-add with updated score
    leaderboard = leaderboard.filter(e => e.isBot);
    
    // Determine player's current best score
    let playerScore = best;
    if (score > 0){
        playerScore = Math.max(best, Math.floor(score));
    }
    
    // Add player with their best score
    if (playerScore > 0){
        leaderboard.push({ name: 'YOU', score: playerScore, isBot: false });
    }
    
    // Sort by score to ensure correct placement
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Find player rank
    playerRank = leaderboard.findIndex(e => !e.isBot) + 1;
    
    saveLeaderboard();
    renderLeaderboard();
}

// Auto-update bots every 5 seconds
let botUpdateInterval = null;
function startBotUpdates(){
    if (botUpdateInterval) return;
    botUpdateInterval = setInterval(() => {
        // Update bot scores autonomously
        leaderboard.forEach(bot => {
            if (bot.isBot && Math.random() < 0.5){ // 50% chance each bot updates
                let change = 0;
                if (bot.style === 'Aggressive') change = Math.floor(Math.random() * 80) - 20; // -20 to +60
                else if (bot.style === 'Defensive') change = Math.floor(Math.random() * 40) - 10; // -10 to +30
                else if (bot.style === 'Risky') change = Math.floor(Math.random() * 120) - 60; // -60 to +60
                
                bot.score = Math.max(100, bot.score + change);
            }
        });
        
        // Re-sort and render
        leaderboard.sort((a, b) => b.score - a.score);
        saveLeaderboard();
        renderLeaderboard();
        updateRivalUI();
    }, 5000); // Update every 5 seconds
}

function stopBotUpdates(){
    if (botUpdateInterval){
        clearInterval(botUpdateInterval);
        botUpdateInterval = null;
    }
}

function renderLeaderboard(){
    const listEl = document.getElementById('leaderboardList');
    if (!listEl) return;
    
    listEl.innerHTML = '';
    
    // Show ALL entries (not just top 10) to ensure scrolling works
    const playerIndex = leaderboard.findIndex(e => !e.isBot);
    
    leaderboard.forEach((entry, idx) => {
        const rank = idx + 1;
        const item = document.createElement('div');
        item.className = 'leaderboard-item' + (!entry.isBot ? ' player' : '');
        
        const rankIcon = rank <= 3 ? ['ü•á', 'ü•à', 'ü•â'][rank - 1] : `#${rank}`;
        
        item.innerHTML = `
            <span class="lb-rank">${rankIcon}</span>
            <span class="lb-name">${entry.name}</span>
            <span class="lb-score">${entry.score.toLocaleString()}</span>
        `;
        
        listEl.appendChild(item);
    });
    
    // Auto-scroll to player position
    if (playerIndex >= 0){
        const playerItem = listEl.children[playerIndex];
        if (playerItem){
            setTimeout(() => {
                playerItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }
    }
}

function selectRival(){
    const playerScore = Math.floor(score) || best;
    const betterBots = leaderboard.filter(b => b.isBot && b.score > playerScore * 1.05 && b.score < playerScore * 1.5);
    
    if (betterBots.length > 0){
        rivalBot = betterBots[Math.floor(Math.random() * betterBots.length)];
    } else {
        // Pick someone from top 10
        const topBots = leaderboard.filter(b => b.isBot).slice(0, 10);
        rivalBot = topBots[Math.floor(Math.random() * topBots.length)];
    }
    
    updateRivalUI();
}

function updateRivalUI(){
    const rivalPanel = document.getElementById('rivalPanel');
    const rivalName = document.getElementById('rivalName');
    const rivalScore = document.getElementById('rivalScore');
    const rivalStatus = document.getElementById('rivalStatus');
    
    if (!rivalBot || !rivalPanel) return;
    
    rivalPanel.style.display = 'block';
    rivalName.textContent = rivalBot.name;
    rivalScore.textContent = rivalBot.score.toLocaleString();
    
    const playerScore = Math.floor(score);
    if (playerScore > rivalBot.score){
        rivalStatus.textContent = '‚úÖ DEFEATED!';
        rivalStatus.style.color = '#4ade80';
    } else {
        const diff = rivalBot.score - playerScore;
        rivalStatus.textContent = `${diff} points ahead`;
        rivalStatus.style.color = '#fbbf24';
    }
}

function renderSkinMenu(){
    // Render Player Skins
    const playerGrid = document.getElementById('playerSkinGrid');
    if (playerGrid){
        playerGrid.innerHTML = '';
        SKINS.player.forEach(skin => {
            const unlocked = skin.unlocked || playerLevel >= skin.unlockLevel;
            const active = activeSkins.player === skin.id;
            
            const card = document.createElement('div');
            card.className = `skin-card ${active ? 'active' : ''} ${!unlocked ? 'locked' : ''}`;
            card.innerHTML = `
                <div class="skin-preview" style="background: ${unlocked ? skin.color : '#333'}">
                    ${!unlocked ? 'üîí' : ''}
                </div>
                <div class="skin-name">${skin.name}</div>
                <div class="skin-unlock">${unlocked ? (active ? '‚úì Active' : 'Click to use') : `Level ${skin.unlockLevel}`}</div>
            `;
            
            if (unlocked) card.addEventListener('click', () => setSkin('player', skin.id));
            playerGrid.appendChild(card);
        });
    }
    
    // Render Laser Skins
    const laserGrid = document.getElementById('laserSkinGrid');
    if (laserGrid){
        laserGrid.innerHTML = '';
        SKINS.laser.forEach(skin => {
            const unlocked = skin.unlocked || playerLevel >= skin.unlockLevel;
            const active = activeSkins.laser === skin.id;
            
            const card = document.createElement('div');
            card.className = `skin-card ${active ? 'active' : ''} ${!unlocked ? 'locked' : ''}`;
            card.innerHTML = `
                <div class="skin-preview" style="background: ${unlocked ? skin.color : '#333'}">
                    ${!unlocked ? 'üîí' : '‚ö°'}
                </div>
                <div class="skin-name">${skin.name}</div>
                <div class="skin-unlock">${unlocked ? (active ? '‚úì Active' : 'Click to use') : `Level ${skin.unlockLevel}`}</div>
            `;
            
            if (unlocked) card.addEventListener('click', () => setSkin('laser', skin.id));
            laserGrid.appendChild(card);
        });
    }
    
    // Render Earth Skins
    const earthGrid = document.getElementById('earthSkinGrid');
    if (earthGrid){
        earthGrid.innerHTML = '';
        SKINS.earth.forEach(skin => {
            const unlocked = skin.unlocked || playerLevel >= skin.unlockLevel;
            const active = activeSkins.earth === skin.id;
            
            const card = document.createElement('div');
            card.className = `skin-card ${active ? 'active' : ''} ${!unlocked ? 'locked' : ''}`;
            card.innerHTML = `
                <div class="skin-preview" style="background: ${unlocked ? skin.color : '#333'}">
                    ${!unlocked ? 'üîí' : skin.name.split(' ')[0]}
                </div>
                <div class="skin-name">${skin.name}</div>
                <div class="skin-unlock">${unlocked ? (active ? '‚úì Active' : 'Click to use') : `Level ${skin.unlockLevel}`}</div>
            `;
            
            if (unlocked) card.addEventListener('click', () => setSkin('earth', skin.id));
            earthGrid.appendChild(card);
        });
    }
}

function initSessionChallenge(){
    const challenges = [
        { title: 'Destroy 100 Asteroids', target: 100, type: 'kills', reward: 'Power-Up Boost' },
        { title: 'Reach 3000 Points', target: 3000, type: 'score', reward: 'Score Multiplier' },
        { title: 'Defeat 2 Bosses', target: 2, type: 'bosses', reward: 'Extra Life' },
        { title: 'Achieve 10x Combo', target: 10, type: 'combo', reward: 'Speed Boost' },
        { title: 'Survive 3 Minutes', target: 180, type: 'time', reward: 'Shield Charge' }
    ];
    
    sessionChallenge = challenges[Math.floor(Math.random() * challenges.length)];
    challengeProgress = 0;
    
    const titleEl = document.getElementById('challengeTitle');
    const textEl = document.getElementById('challengeText');
    if (titleEl) titleEl.textContent = sessionChallenge.title;
    if (textEl) textEl.textContent = `0 / ${sessionChallenge.target}`;
}

function updateChallenge(type, value){
    if (!sessionChallenge || sessionChallenge.type !== type) return;
    
    challengeProgress = value;
    const percent = Math.min(100, (challengeProgress / sessionChallenge.target) * 100);
    
    const fillEl = document.getElementById('challengeFill');
    const textEl = document.getElementById('challengeText');
    const rewardEl = document.getElementById('challengeReward');
    
    if (fillEl) fillEl.style.width = `${percent}%`;
    if (textEl) textEl.textContent = `${challengeProgress} / ${sessionChallenge.target}`;
    
    if (challengeProgress >= sessionChallenge.target && rewardEl){
        rewardEl.style.display = 'block';
    }
}
const comboDuration = 2.0;

// Screen shake
let screenShake = 0.0;

// Boss / PowerUps / SlowTime
let bossActive = false;
let nextBossScore = 800;
const bossScoreInterval = 800;
let bossObj = null; // reference to active boss
let bossesKilled = 0; // Boss counter
let powerUps = [];
let slowCharges = 0;
let slowTimer = 0;
let nukeReady = false; // Is Nuke available to activate
let slowCooldown = 0;
const slowDuration = 0.9;
const slowCooldownDuration = 10; // seconds between auto slows
let timeScale = 1.0; // dt multiplier (1.0 normal)

function updatePowerUI(){
    const el = document.getElementById('slowCount'); if (el) el.textContent = String(slowCharges);
    const puChip = document.getElementById('powerupChip');
    const puLabel = document.getElementById('powerupLabel');
    const puValue = document.getElementById('powerupValue');
    if (activePowerUp && POWER_UPS[activePowerUp]){
        const pu = POWER_UPS[activePowerUp];
        if (puChip) {
            puChip.style.display = 'flex';
            puChip.style.borderColor = pu.color;
            if (puLabel) puLabel.textContent = pu.category.slice(0,3);
            if (puValue) {
                const remaining = Math.max(0, Math.ceil(powerUpTimer * 10) / 10);
                puValue.textContent = pu.duration > 0 ? remaining.toFixed(1) : '‚àû';
            }
        }
    } else if (puChip){
        puChip.style.display = 'none';
    }
}
function updateBossUI(){
    const el = document.getElementById('bossHP'); if (el) el.textContent = bossActive && bossObj ? String(bossObj.hp) : '0';
}

function updateBossCounter(){
    const el = document.getElementById('bossesKilled'); if (el) el.textContent = String(bossesKilled);
}

const core = { x: w/2, y: H/2, r: 18};

const orbit = {
    r: Math.min(w,H) * 0.22, // Reduced from 0.28 for better balance on small screens
    angle: 0,
    dir: 1,
    omega: 2.6,};

const player = { r: 10};

function updateHPUI(){
    if (!hpEL) return;
    hpEL.textContent = String(coreHP);
    if (hpFill){ hpFill.style.width = (coreHP / coreMaxHP * 100) + '%'; }
}

function updateComboUI(){
    const el = document.getElementById('combo');
    if (el) el.textContent = 'x' + combo;
    // style chip based on level
    const chips = Array.from(document.querySelectorAll('.chip'));
    for (const c of chips){ if (c.textContent.includes('Combo')){
            c.classList.remove('combo-2','combo-3','combo-4','combo');
            if (combo >= 4){ c.classList.add('combo-4'); }
            else if (combo === 3){ c.classList.add('combo-3'); }
            else if (combo === 2){ c.classList.add('combo-2'); }
            else { c.classList.add('combo'); }
            // ensure transient pulse
            setTimeout(()=>{ c.classList.remove('combo'); if (combo >= 2) c.classList.add('combo'); }, 680);
            break;
        } }
}

function resetGame() {
    score = 0;
    coreHP = coreMaxHP;
    combo = 1; comboTimer = 0; updateComboUI();

    orbit.angle = 0;
    orbit.dir = 1;
    scoreEL.textContent = "0";
    updateHPUI();
} 

function closeStartStatsPanel(){
    try{
        const startStatsPanel = document.getElementById('startStatsPanel');
        const toggleStatsBtn = document.getElementById('toggleStatsBtn');
        if (startStatsPanel) {
            startStatsPanel.classList.remove('is-open');
            startStatsPanel.setAttribute('aria-hidden', 'true');
            startStatsPanel.hidden = true;
            startStatsPanel.style.setProperty('display', 'none', 'important');
        }
        if (toggleStatsBtn) toggleStatsBtn.textContent = 'üìä STATS';
    }catch(e){}
}

function startGame() {
    console.log('startGame invoked');
    resetGame();
    closeStartStatsPanel();
    running = true;
    overlay.classList.add("hidden");
    overlay.classList.remove("open");
    lastTime = performance.now();
    startAudioIfNeeded();
    playBackgroundMusic(); // Start roguelike music
    
    // Initialize leaderboard and challenge systems
    if (leaderboard.length === 0) initLeaderboard();
    if (!sessionChallenge) initSessionChallenge();
    selectRival();
    updateLeaderboard();
    
    requestAnimationFrame(loop);
}

function gameOver() {
    running = false;
    closeStartStatsPanel();
    stopBackgroundMusic(); // Stop roguelike music
    
    // === "SO CLOSE" FEELING + FEEDBACK ===
    const closeToGoal = checkCloseToGoal();
    if (closeToGoal){
        showCloseMessage(closeToGoal);
    } else {
        // No close goal, just show a motivational message on loss
        showGameOverFeedback();
    }
    
    if (score > best) {
        best = Math.floor(score);
        localStorage.setItem("best_orbit_guardian", String(best));
        bestEL.textContent = String(best);
    }
    
    // Update leaderboard and rival
    updateLeaderboard();
    updateRivalUI();
    
    overlay.classList.remove("hidden");
    overlay.classList.add("open");
    // reset combo and update UI
    combo = 1; comboTimer = 0; updateComboUI();
    // update UI
    updateHPUI();
    // sound and music stop
    startAudioIfNeeded();
    playExplosion();
    stopMusic();
}

function showGameOverFeedback(){
    // Determine rarity based on score or combo at death
    let rarity = 'common';
    const baseScore = Math.floor(score);
    
    if (baseScore >= 5000) rarity = 'legendary';
    else if (baseScore >= 3000) rarity = 'epic';
    else if (baseScore >= 1500) rarity = 'rare';
    else if (baseScore >= 500) rarity = 'uncommon';
    else rarity = 'common';
    
    // Game Over messages by rarity
    const messages = {
        common: [
            { de: 'Nochmal.', en: 'Again.' },
            { de: 'Fast.', en: 'Close.' },
            { de: 'Nicht schlecht.', en: 'Not bad.' },
            { de: 'Weiter geht\'s.', en: 'Let\'s go again.' },
            { de: 'Das war okay.', en: 'That was okay.' },
            { de: 'Neuer Versuch.', en: 'New attempt.' },
            { de: 'Bleib dran.', en: 'Stay with it.' },
            { de: 'Du lernst.', en: 'You\'re learning.' },
            { de: 'Kurz verloren.', en: 'Short run.' },
            { de: 'Weiter k√§mpfen.', en: 'Keep fighting.' }
        ],
        uncommon: [
            { de: 'Das war knapp.', en: 'That was close.' },
            { de: 'Du warst dran.', en: 'You were close.' },
            { de: 'Noch ein Run.', en: 'One more run.' },
            { de: 'Es wird besser.', en: 'It\'s getting better.' },
            { de: 'Du kommst n√§her.', en: 'You\'re getting closer.' },
            { de: 'Timing fast perfekt.', en: 'Timing almost perfect.' },
            { de: 'Das hast du gleich.', en: 'You\'ll get it.' },
            { de: 'Nicht aufgeben.', en: 'Don\'t give up.' },
            { de: 'Fast geschafft.', en: 'Almost made it.' },
            { de: 'N√§chstes Mal.', en: 'Next time.' }
        ],
        rare: [
            { de: 'So nah dran.', en: 'So close.' },
            { de: 'Ein Treffer fehlte.', en: 'One hit away.' },
            { de: 'Das war √§rgerlich.', en: 'That hurts.' },
            { de: 'Du hattest die Kontrolle.', en: 'You had control.' },
            { de: 'Ein Fehler.', en: 'One mistake.' },
            { de: 'Fast perfekt gespielt.', en: 'Almost perfect play.' },
            { de: 'Das Chaos hat gewonnen.', en: 'Chaos won this time.' },
            { de: 'Du warst besser.', en: 'You were better.' },
            { de: 'Ungl√ºcklich.', en: 'Unlucky.' },
            { de: 'Noch nicht vorbei.', en: 'Not over yet.' }
        ],
        epic: [
            { de: 'Das h√§tte deiner sein k√∂nnen.', en: 'That could\'ve been yours.' },
            { de: 'Du warst im Flow.', en: 'You were in the zone.' },
            { de: 'Ein Moment hat gefehlt.', en: 'One moment short.' },
            { de: 'Fast gemeistert.', en: 'Nearly mastered.' },
            { de: 'Das tat weh.', en: 'That hurt.' },
            { de: 'Du hattest es.', en: 'You had it.' },
            { de: 'Das war dein Run.', en: 'That was your run.' },
            { de: 'Das Universum hat gezuckt.', en: 'The universe flinched.' },
            { de: 'Knapp daneben.', en: 'So close to victory.' },
            { de: 'Das war brutal.', en: 'That was brutal.' }
        ],
        legendary: [
            { de: 'So verliert man Legenden.', en: 'That\'s how legends fall.' },
            { de: 'Das war nicht das Ende.', en: 'This isn\'t the end.' },
            { de: 'Du warst bereit.', en: 'You were ready.' },
            { de: 'Ein perfekter Fehler.', en: 'A perfect mistake.' },
            { de: 'Das System hat dich gestoppt.', en: 'The system stopped you.' },
            { de: 'Das war Schicksal.', en: 'That was fate.' },
            { de: 'Du kommst zur√ºck.', en: 'You will return.' },
            { de: 'Fast unsterblich.', en: 'Almost immortal.' },
            { de: 'Das Spiel wei√ü es.', en: 'The game knows.' },
            { de: 'Noch nicht heute.', en: 'Not today.' }
        ]
    };
    
    const msgList = messages[rarity];
    const msg = msgList[Math.floor(Math.random() * msgList.length)];
    
    const feedback = document.createElement('div');
    feedback.className = `feedback-message feedback-gameover feedback-${rarity}`;
    feedback.textContent = msg.de;
    feedback.style.zIndex = '9999';
    feedback.style.position = 'fixed';
    feedback.style.top = '40%';
    feedback.style.left = '50%';
    feedback.style.transform = 'translate(-50%, -50%)';
    document.body.appendChild(feedback);
    
    // Different effects based on rarity
    let timeScaleValue = 0.3;
    let duration = 1500;
    let screenShakeAmount = 0;
    
    if (rarity === 'uncommon'){
        timeScaleValue = 0.4;
        duration = 1800;
        screenShakeAmount = 5;
    } else if (rarity === 'rare'){
        timeScaleValue = 0.3;
        duration = 2000;
        screenShakeAmount = 8;
    } else if (rarity === 'epic'){
        timeScaleValue = 0.2;
        duration = 2200;
        screenShakeAmount = 15;
    } else if (rarity === 'legendary'){
        timeScaleValue = 0.15;
        duration = 2500;
        screenShakeAmount = 25;
    }
    
    // Zeitlupe-Effekt
    timeScale = timeScaleValue;
    if (screenShakeAmount > 0) screenShake = screenShakeAmount;
    
    setTimeout(() => { timeScale = 1; }, duration);
    
    console.log(`[GAME OVER - ${rarity.toUpperCase()}] ${msg.de} (Score: ${baseScore})`);
    
    setTimeout(() => feedback.remove(), 3000);
}

function checkCloseToGoal(){
    // Check if player was close to something
    const xpNeeded = getXPForLevel(playerLevel);
    const xpRemaining = xpNeeded - playerXP;
    
    if (xpRemaining <= 20) return { type: 'level', text: `Nur noch ${xpRemaining} XP bis Level-Up...` };
    if (coreHP === 1) return { type: 'hp', text: 'One more hit...' };
    if (sessionChallenge && sessionChallenge.progress >= sessionChallenge.target * 0.9){
        return { type: 'challenge', text: 'So close to challenge...' };
    }
    if (rivalBot && Math.abs(rivalBot.score - score) < 100){
        return { type: 'rival', text: `Fast deinen Rivalen besiegt...` };
    }
    return null;
}

function showCloseMessage(closeInfo){
    // Freeze effect - slow down time dramatically
    timeScale = 0.2;
    setTimeout(() => { timeScale = 1; }, 2000);
    
    const closeMsg = document.createElement('div');
    closeMsg.className = 'close-message';
    closeMsg.innerHTML = `
        <div class="close-text">${closeInfo.text}</div>
        <div class="close-subtext">Das schaffst du gleich.</div>
    `;
    document.body.appendChild(closeMsg);
    
    // Screen shake
    screenShake = 25;
    
    setTimeout(() => closeMsg.remove(), 4000);
}

function tap() {
    if (!running) return;
    orbit.dir *= -1;
    // sound feedback and ensure audio context can start after user gesture
    startAudioIfNeeded();
    playBeep();
}

function draw() {
    ctx.clearRect(0,0,w,H);
    // screen shake effect (translate canvas for impact)
    ctx.save();
    if (screenShake > 0){ const sx = (Math.random()*2 - 1) * screenShake; const sy = (Math.random()*2 - 1) * screenShake; ctx.translate(Math.floor(sx), Math.floor(sy)); }

    // Stars (pixel)
    ctx.globalAlpha = 0.35;
    for (let i = 0; i < 35; i++) {
        const x = Math.floor((i * 97) % w);
        const y = Math.floor((i * 173) % H);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;

    // Offscreen indicators for asteroids (arrows on screen edge)
    drawOffscreenIndicators();

    // Orbit ring (crisp)
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(Math.floor(core.x) + 0.5, Math.floor(core.y) + 0.5, Math.floor(orbit.r), 0, Math.PI*2);
    ctx.stroke();

    // HP ring (segments)
    const segments = coreMaxHP;
    const ringR = Math.floor(orbit.r) - 8;
    ctx.lineWidth = 3;
    for (let s = 0; s < segments; s++){
        const start = (s/segments) * Math.PI*2 - Math.PI/2;
        const end = ((s+1)/segments) * Math.PI*2 - Math.PI/2 - 0.02;
        ctx.beginPath();
        ctx.strokeStyle = s < coreHP ? '#2eea8a' : 'rgba(255,255,255,0.06)';
        ctx.arc(core.x, core.y, ringR, start, end);
        ctx.stroke();
    }

    // Core: draw earth sprite centered
    const earthSize = Math.max(8, Math.floor(core.r * 2.8));
    if (earthCanvas && earthCanvas.width > 0 && earthCanvas.height > 0){
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(earthCanvas, Math.floor(core.x - earthSize/2), Math.floor(core.y - earthSize/2), earthSize, earthSize);
    } else {
        const coreSize = Math.max(2, Math.floor(core.r * 2));
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(Math.floor(core.x - coreSize / 2), Math.floor(core.y - coreSize / 2), coreSize, coreSize);
    }

    // Player pixel ship - use active skin
    const playerSkin = getActiveSkin('player');
    const px = Math.floor(core.x + Math.cos(orbit.angle) * orbit.r);
    const py = Math.floor(core.y + Math.sin(orbit.angle) * orbit.r);
    const s = 6;
    // glow
    ctx.fillStyle = hexToRGBA(playerSkin.color, 0.18);
    ctx.fillRect(px - Math.floor((s + 2) / 2), py - Math.floor((s + 2) / 2), s + 2, s + 2);
    // main pixel
    ctx.fillStyle = playerSkin.color;
    ctx.fillRect(px - Math.floor(s / 2), py - Math.floor(s / 2), s, s);

    // Draw boss warning if active
    if (bossWarning){
        drawBossWarning();
    }

    ctx.restore();
}

function drawBossWarning(){
    if (!bossWarning) return;
    
    const elapsed = timeElapsed - bossWarning.startTime;
    const progress = elapsed / 2.0; // 0 to 1 over 2 seconds
    
    // Determine color and scale
    let color, scale, wobble;
    if (bossWarning.warningPhase === 'yellow'){
        // First 1 second: yellow, grows from 1 to 1.8, wobbles slowly
        const t = elapsed;
        color = '#ffff00';
        scale = 1.0 + Math.sin(t * 8) * 0.4 + t * 0.4; // grows + wobbles
        wobble = Math.sin(t * 12) * 8;
    } else {
        // Last 1 second: red, pulses fast, shakes
        const t = elapsed - 1.0;
        color = '#ff3333';
        scale = 1.8 + Math.sin(t * 20) * 0.3; // pulses
        wobble = (Math.random() - 0.5) * 20; // violent shake
        screenShake = Math.max(screenShake, 6);
    }
    
    // Draw centered ! at top
    ctx.save();
    ctx.font = `bold ${Math.floor(80 * scale)}px 'Courier New'`;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.globalAlpha = 0.9;
    ctx.fillText('!', Math.floor(w/2 + wobble), Math.floor(H * 0.15 + wobble));
    ctx.restore();
}

// === POWER-UP SYSTEM ===
const POWER_UPS = {
    SHIELD: { name: 'Shield', category: 'DEFENSIV', color: '#4a9eff', duration: 20, rarity: 0.4 },
    CORE_REPAIR: { name: 'Core Repair', category: 'DEFENSIV', color: '#4eff9a', duration: 0, rarity: 0.3 },
    RAPID_FIRE: { name: 'Rapid Fire', category: 'OFFENSIV', color: '#ff6b4a', duration: 18, rarity: 0.35 },
    PIERCING_SHOTS: { name: 'Piercing Shots', category: 'OFFENSIV', color: '#ffaa3b', duration: 20, rarity: 0.3 },
    EXPLOSION_SHOTS: { name: 'Explosion Shots', category: 'OFFENSIV', color: '#ff5c3b', duration: 18, rarity: 0.25 },
    TIME_SLOW: { name: 'Time Slow', category: 'CONTROL', color: '#a84aff', duration: 16, rarity: 0.25 },
    MAGNET_SHOTS: { name: 'Magnet Shots', category: 'CONTROL', color: '#3bffff', duration: 18, rarity: 0.3 },
    ORBIT_BOOST: { name: 'Orbit Boost', category: 'CONTROL', color: '#ffff4a', duration: 16, rarity: 0.35 },
    NUKE: { name: 'Nuke', category: 'SPECIAL', color: '#ff3b3b', duration: 0, rarity: 0.15 },
    BULLET_STORM: { name: 'Bullet Storm', category: 'SPECIAL', color: '#ff00ff', duration: 14, rarity: 0.15 },
    PRECISION_MODE: { name: 'Precision Mode', category: 'SPECIAL', color: '#00ffff', duration: 20, rarity: 0.1 }
};

let activePowerUp = null;
let powerUpTimer = 0;
let shieldHP = 0;
let piercingActive = false;
let explosionActive = false;
let magnetActive = false;
let rapidFireMultiplier = 1.0;
let orbitBoostMultiplier = 1.0;
let timeSlowMultiplier = 1.0;

function grantRandomPowerUp() {
    const weights = Object.values(POWER_UPS).map(p => p.rarity);
    const totalWeight = weights.reduce((a,b) => a+b, 0);
    let rand = Math.random() * totalWeight;
    let selected = null;
    
    for (const [key, powerUp] of Object.entries(POWER_UPS)) {
        rand -= powerUp.rarity;
        if (rand <= 0) { selected = key; break; }
    }
    
    if (!selected) selected = 'CORE_REPAIR';
    activatePowerUp(selected);
}

function activatePowerUp(key) {
    const powerUp = POWER_UPS[key];
    if (!powerUp) return;
    
    activePowerUp = key;
    powerUpTimer = powerUp.duration;
    
    // Immediate effects
    if (key === 'CORE_REPAIR') { coreHP = Math.min(coreMaxHP, coreHP + 1); updateHPUI(); }
    if (key === 'SHIELD') { shieldHP = 2; }
    if (key === 'NUKE') { asteroids.length = 0; }
    if (key === 'PIERCING_SHOTS') { piercingActive = true; }
    if (key === 'EXPLOSION_SHOTS') { explosionActive = true; }
    if (key === 'MAGNET_SHOTS') { magnetActive = true; }
    if (key === 'RAPID_FIRE') { rapidFireMultiplier = 2.5; }
    if (key === 'ORBIT_BOOST') { orbitBoostMultiplier = 1.8; }
    if (key === 'TIME_SLOW') { timeSlowMultiplier = 0.5; }
    if (key === 'BULLET_STORM') { rapidFireMultiplier = 3.5; }
    if (key === 'PRECISION_MODE') { timeSlowMultiplier = 0.4; }
    
    // Nuke: ready to activate with button
    if (key === 'NUKE') { 
        nukeReady = true;
        updateNukeUI();
    }
    
    // Audio & visual feedback
    // startAudioIfNeeded();
    // playMusicNote(880, 0.15, 'sine');
    // playMusicNote(1320, 0.15, 'sine');
    screenShake = 8;
    
    // Show power-up overlay
    showPowerUpOverlay(key);
    console.log(`Power-Up: ${powerUp.name}`);
}

function showPowerUpOverlay(key) {
    const powerUp = POWER_UPS[key];
    if (!powerUp) return;
    
    const overlay = document.getElementById('powerupOverlay');
    if (!overlay) return;
    
    // Map power-ups to icons and descriptions
    const icons = {
        SHIELD: 'üõ°Ô∏è', CORE_REPAIR: '‚ù§Ô∏è', RAPID_FIRE: '‚ö°', PIERCING_SHOTS: '‚Üí',
        EXPLOSION_SHOTS: 'üí•', TIME_SLOW: '‚è±Ô∏è', MAGNET_SHOTS: 'üß≤', ORBIT_BOOST: 'üåÄ',
        NUKE: '‚ò¢Ô∏è', BULLET_STORM: 'üå©Ô∏è', PRECISION_MODE: 'üéØ'
    };
    
    const descriptions = {
        SHIELD: 'Blocks 2 asteroid hits', CORE_REPAIR: '+1 HP restored',
        RAPID_FIRE: '2.5√ó fire rate', PIERCING_SHOTS: 'Shots pierce asteroids',
        EXPLOSION_SHOTS: 'Explosions damage nearby', TIME_SLOW: '50% speed',
        MAGNET_SHOTS: 'Attract asteroids', ORBIT_BOOST: '1.8√ó rotation',
        NUKE: 'Clear all asteroids', BULLET_STORM: '3.5√ó fire rate',
        PRECISION_MODE: '60% speed, 8s'
    };
    
    overlay.innerHTML = `
        <div class="icon">${icons[key] || '‚≠ê'}</div>
        <div class="name">${powerUp.name}</div>
        <div class="description">${descriptions[key] || 'Power-up activated!'}</div>
    `;
    overlay.style.borderColor = powerUp.color;
    overlay.style.display = 'flex';
    overlay.classList.remove('hidden');
    
    // Auto-hide after 2.5 seconds
    setTimeout(() => {
        overlay.classList.add('hidden');
        setTimeout(() => { overlay.style.display = 'none'; }, 300);
    }, 2500);
}

function deactivatePowerUp() {
    if (!activePowerUp) return;
    piercingActive = false;
    explosionActive = false;
    magnetActive = false;
    rapidFireMultiplier = 1.0;
    orbitBoostMultiplier = 1.0;
    timeSlowMultiplier = 1.0;
    shieldHP = 0;
    activePowerUp = null;
    nukeReady = false;
    updateNukeUI();
}

function activateNuke() {
    if (!nukeReady) return;
    asteroids.length = 0; // Clear all asteroids
    screenShake = 20;
    startAudioIfNeeded();
    playMusicNote(220, 0.3, 'sine');
    playMusicNote(110, 0.4, 'sine');
    for (let i = 0; i < 40; i++){
        const a = Math.random() * Math.PI * 2;
        const speed = 100 + Math.random() * 150;
        particles.push({ x: w/2, y: H/2, vx: Math.cos(a) * speed, vy: Math.sin(a) * speed, life: 1.0 + Math.random() * 0.5 });
    }
    nukeReady = false;
    updateNukeUI();
    console.log('NUKE ACTIVATED!');
}

function updateNukeUI(){
    const nukeBtn = document.getElementById('nukeButton');
    if (!nukeBtn) return;
    if (nukeReady){
        nukeBtn.style.display = 'flex';
        nukeBtn.style.borderColor = '#ff3b3b';
        nukeBtn.style.background = 'linear-gradient(135deg, rgba(255, 59, 59, 0.2), rgba(255, 59, 59, 0.1))';
        document.getElementById('nukeStatus').textContent = 'READY!';
    } else {
        nukeBtn.style.display = 'none';
    }
}

// === ASTEROIDS / BULLETS / PARTICLES ===
let asteroids = [];
let bullets = [];
let particles = [];
let spawnTimer = 0;
const initialSpawnEvery = 1.2;
let spawnEvery = initialSpawnEvery;
const minSpawnEvery = 0.5;
const spawnDecayRate = 0.002; // slow time-based decay
const baseAsteroidSpeed = 40;
let asteroidSpeed = baseAsteroidSpeed;
const speedIncreaseRate = 0.03; // slow increase per second
const maxAsteroidSpeed = 220;
let timeElapsed = 0;

let shootTimer = 0;
let shootEvery = 0.18;

function spawnAsteroid(){
    if (bossActive) return; // no normal spawns while boss alive
    const ang = Math.random() * Math.PI * 2;
    const dist = Math.max(w,H) * 0.9 + 40;
    const x = core.x + Math.cos(ang) * dist;
    const y = core.y + Math.sin(ang) * dist;
    let speed = asteroidSpeed + Math.random() * 30;
    const dx = core.x - x;
    const dy = core.y - y;
    const len = Math.hypot(dx, dy) || 1;
    const vx = dx / len * speed;
    const vy = dy / len * speed;
    const sprite = asteroidSprites.length ? asteroidSprites[Math.floor(Math.random() * asteroidSprites.length)] : null;

    const r = Math.random();
    let type = 'med'; let radius = 10 + Math.random()*8; let hp = 1; let scoreValue = 15;
    if (r < 0.45){ type = 'small'; radius = 6 + Math.random()*4; speed *= 1.4; hp = 1; scoreValue = 10; }
    else if (r < 0.85){ type = 'med'; radius = 10 + Math.random()*8; hp = 1; scoreValue = 15; }
    else { type = 'big'; radius = 18 + Math.random()*12; speed *= 0.6; hp = 2 + Math.floor(Math.random()*2); scoreValue = 30; }

    asteroids.push({ x, y, vx: dx/len*speed, vy: dy/len*speed, radius, sprite, type, hp, scoreValue });
}

function spawnBoss(){
    bossActive = true;
    // Boss spawns only from top or bottom
    const fromTop = Math.random() < 0.5;
    const dist = Math.max(w,H) * 0.95 + 60;
    const x = core.x + (Math.random() - 0.5) * w * 0.8; // Random horizontal position
    const y = fromTop ? (core.y - dist) : (core.y + dist);
    const dx = core.x - x; const dy = core.y - y; const len = Math.hypot(dx,dy) || 1;
    const speed = Math.max(18, baseAsteroidSpeed * 0.35);
    const radius = Math.floor(Math.min(Math.max(w,H) * 0.12, 72));
    const hp = 18 + Math.floor(Math.random() * 10);
    
    // Load boss sprite if not already loaded
    if (!bossSprite) {
        bossSprite = new Image();
        bossSprite.onload = () => { /* Boss sprite loaded */ };
        bossSprite.onerror = () => {
            // Fallback: create boss sprite from canvas
            console.warn('Boss sprite image not found, creating from canvas');
            const c = document.createElement('canvas');
            c.width = c.height = 64;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#4a5a7a';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#8a9aaa';
            ctx.fillRect(20, 25, 8, 8);
            ctx.fillRect(36, 25, 8, 8);
            ctx.fillRect(24, 40, 16, 6);
            bossSprite.src = c.toDataURL();
        };
        bossSprite.src = 'boss.png';
    }
    
    bossObj = { x, y, vx: dx/len*speed, vy: dy/len*speed, radius, hp, type: 'boss', isBoss: true, sprite: bossSprite };
    asteroids.push(bossObj);
    // make it dramatic: pause normal spawn timer longer
    spawnTimer = Math.max(2.4, spawnEvery * 2.0);
    // big shake and sound
    screenShake = 14; 
    // startAudioIfNeeded(); playMusicNote(220, 0.9, 'sawtooth');
    updateBossUI();
}

function shootOnce(manual = false){
    if (shootTimer > 0 || !running) return;
    const px = core.x + Math.cos(orbit.angle) * orbit.r;
    const py = core.y + Math.sin(orbit.angle) * orbit.r;
    const speed = 260;
    const vx = Math.cos(orbit.angle) * speed;
    const vy = Math.sin(orbit.angle) * speed;
    let bullet = { x: px, y: py, vx, vy, life: 2, speed, manual, hit: false };
    
    // Apply power-up effects
    if (piercingActive) bullet.piercing = true;
    if (explosionActive) bullet.explosive = true;
    if (magnetActive) bullet.magnet = true;

    // Aim assist (fair): stronger but bounded homing to a nearby target within angle/range
    if (isAimAssistEnabled()){
        const aimRange = 520; // increased range
        const maxAngle = Math.PI * 0.45; // wider acceptance (~81¬∞)
        let best = null, bestDist = 1e9;
        for (const a of asteroids){
            const dx = a.x - px, dy = a.y - py;
            const dist = Math.hypot(dx,dy);
            if (dist > aimRange) continue;
            const dirDot = (dx*vx + dy*vy) / (dist * speed);
            const angle = Math.acos(Math.max(-1, Math.min(1, dirDot)));
            if (angle <= maxAngle && dist < bestDist){ best = a; bestDist = dist; }
        }
        if (best){ bullet.target = best; bullet.homing = true; bullet.homingFactor = 4.0; } // stronger homing
        // small fire-rate penalty to keep it fair
        shootTimer = shootEvery + 0.06;
    } else {
        shootTimer = shootEvery;
    }
    
    // Apply Rapid Fire & Bullet Storm multipliers
    shootTimer /= rapidFireMultiplier;

    bullets.push(bullet);
    startAudioIfNeeded(); playBeep(1200, 0.06);
}  

function explode(x,y,count){
    for (let i=0;i<count;i++){
        const a = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 80;
        particles.push({ x, y, vx: Math.cos(a) * speed, vy: Math.sin(a) * speed, life: 0.5 + Math.random() * 0.6 });
    }
    // trigger screen shake
    screenShake = Math.max(screenShake, Math.min(12, count/2));
}

function drawAsteroids(){
    for (const a of asteroids){
        const r = Math.max(4, Math.floor(a.radius));
        if (a.sprite && a.sprite.complete && a.sprite.naturalWidth > 0) {
            ctx.imageSmoothingEnabled = false;
            try {
                ctx.drawImage(a.sprite, Math.floor(a.x - r), Math.floor(a.y - r), r*2, r*2);
            } catch (e) {
                ctx.fillStyle = '#bfbfbf';
                ctx.fillRect(Math.floor(a.x - r), Math.floor(a.y - r), r*2, r*2);
            }
        } else {
            ctx.fillStyle = '#bfbfbf';
            ctx.fillRect(Math.floor(a.x - r), Math.floor(a.y - r), r*2, r*2);
        }
    }
}

function drawBullets(){
    const laserSkin = getActiveSkin('laser');
    ctx.fillStyle = laserSkin.color;
    for (const b of bullets){
        ctx.fillRect(Math.floor(b.x)-1, Math.floor(b.y)-1, 2, 2);
    }
}

function drawParticles(){
    for (const p of particles){
        const alpha = Math.max(0, Math.min(1, p.life));
        ctx.fillStyle = `rgba(255,200,120,${alpha})`;
        ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 2, 2);
    }
}

function drawPowerUps(){
    for (const pu of powerUps){
        const t = performance.now();
        const pulse = 1 + Math.sin(t/160) * 0.12;
        ctx.save(); ctx.globalAlpha = 0.95; ctx.translate(pu.x, pu.y); ctx.scale(pulse,pulse);
        if (pu.type === 'slow'){
            ctx.fillStyle = 'rgba(120,200,255,0.95)'; ctx.fillRect(-6,-6,12,12);
            ctx.fillStyle = '#042'; ctx.fillRect(-2,-2,4,4);
        } else { ctx.fillStyle = '#fff'; ctx.fillRect(-4,-4,8,8); }
        ctx.restore();
    }
}

function drawOffscreenIndicators(){
    if (!asteroids || asteroids.length === 0) return;
    const off = asteroids.filter(a => (a.x < -50 || a.x > w + 50 || a.y < -50 || a.y > H + 50));
    if (!off.length) return;
    off.sort((A,B) => Math.hypot(A.x-core.x,A.y-core.y) - Math.hypot(B.x-core.x,B.y-core.y));
    const now = performance.now();
    const maxShow = 6; // Show more indicators
    
    for (let i=0; i<Math.min(maxShow, off.length); i++){
        const a = off[i];
        const dx = a.x - core.x, dy = a.y - core.y;
        const ang = Math.atan2(dy, dx);
        const dirx = Math.cos(ang), diry = Math.sin(ang);
        
        // Calculate edge intersection more accurately
        const tx = dirx > 0 ? (w - 20 - core.x) / dirx : (20 - core.x) / dirx;
        const ty = diry > 0 ? (H - 20 - core.y) / diry : (20 - core.y) / diry;
        let t = Math.min(Math.abs(tx), Math.abs(ty));
        
        let ix = core.x + dirx * t;
        let iy = core.y + diry * t;
        
        // Clamp to screen edge with margin
        const margin = 16;
        ix = Math.max(margin, Math.min(w - margin, ix));
        iy = Math.max(margin, Math.min(H - margin, iy));
        
        const dist = Math.hypot(dx, dy);
        const screenDist = Math.max(w, H);
        
        // Gr√∂√üere Sichtbarkeit wenn n√§her
        const alpha = Math.min(1, 0.4 + (screenDist - dist) / screenDist * 0.6);
        
        // Color based on asteroid type and proximity
        let col = '#ffff00'; // small = yellow
        let isBoss = a.isBoss || a.type === 'boss';
        
        if (isBoss) col = '#ff3333'; // Boss = bright red
        else if (a.type === 'med') col = '#ffaa33'; // medium = orange
        else if (a.type === 'big') col = '#ff5555'; // big = red
        
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(ix, iy);
        ctx.rotate(ang);
        
        // Pulse effect - stronger for closer asteroids
        const proximityFactor = 1 - Math.min(1, dist / screenDist);
        const pulse = 1 + Math.sin(now / 150 + i) * (0.15 + proximityFactor * 0.2);
        ctx.scale(pulse, pulse);
        
        // Draw larger arrow
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(0, -16); // top point
        ctx.lineTo(12, 12);  // bottom right
        ctx.lineTo(0, 6);    // inner point
        ctx.lineTo(-12, 12); // bottom left
        ctx.closePath();
        ctx.fill();
        
        // Border for clarity
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.stroke();
        
        // Distance indicator - glow ring when very close
        if (dist < screenDist * 0.4){
            ctx.globalAlpha = Math.max(0, alpha * 0.5);
            ctx.strokeStyle = col;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 22, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

// --- Default asteroid sprite generator (used if no upload is provided) ---
function createDefaultAsteroidSprites(){
    if (asteroidSprites && asteroidSprites.length) return; // already populated
    asteroidSprites = [];
    const variants = 4;
    for (let v = 0; v < variants; v++){
        const size = 24 + v * 6;
        const c = document.createElement('canvas');
        c.width = c.height = size;
        const cx = c.getContext('2d');
        cx.imageSmoothingEnabled = false;
        cx.clearRect(0,0,size,size);
        const grid = Math.ceil(size/2);
        for (let y=0;y<grid;y++){
            for (let x=0;x<grid;x++){
                const nx = x - grid/2 + (Math.random()*0.8-0.4);
                const ny = y - grid/2 + (Math.random()*0.8-0.4);
                const dist = Math.hypot(nx, ny);
                const maxr = grid/2 - 0.5 + v*0.2;
                if (dist < maxr + (Math.random()*0.3-0.15)){
                    const shade = 150 - Math.floor(Math.random()*60) - v*8;
                    cx.fillStyle = `rgb(${shade},${shade},${shade})`;
                    cx.fillRect(Math.floor(x*size/grid), Math.floor(y*size/grid), Math.ceil(size/grid), Math.ceil(size/grid));
                }
            }
        }
        // add some darker spots
        for (let i=0;i<4;i++){
            const rx = Math.floor(Math.random() * size * 0.6 + size*0.2);
            const ry = Math.floor(Math.random() * size * 0.6 + size*0.2);
            cx.fillStyle = 'rgba(40,40,40,0.6)';
            cx.fillRect(rx, ry, Math.ceil(size*0.12), Math.ceil(size*0.12));
        }
        const img = new Image();
        img.onload = () => { /* Image loaded and ready */ };
        img.src = c.toDataURL('image/png');
        asteroidSprites.push(img);
    }
}

function update(dt){
    // time/difficulty progression (slow, smooth)
    timeElapsed += dt;
    spawnEvery = Math.max(minSpawnEvery, initialSpawnEvery * Math.exp(-spawnDecayRate * timeElapsed));
    asteroidSpeed = Math.min(maxAsteroidSpeed, baseAsteroidSpeed + speedIncreaseRate * timeElapsed);
    const difficulty = 1 + Math.max(0, (asteroidSpeed - baseAsteroidSpeed) / 20 + (initialSpawnEvery / spawnEvery - 1) * 0.6);
    const diffEl = document.getElementById('diff'); if (diffEl) diffEl.textContent = difficulty.toFixed(2);

    // spawn (skip when a boss is active)
    spawnTimer -= dt;
    if (!bossActive && spawnTimer <= 0){ spawnTimer = spawnEvery; spawnAsteroid(); }

    // check boss spawn by score
    if (!bossActive && !bossWarning && Math.floor(score) >= nextBossScore){
        // Start warning 2 seconds before spawn
        bossWarning = { startTime: timeElapsed, warningPhase: 'yellow' };
        startAudioIfNeeded(); playBeep(880, 0.08);
    }
    
    // Boss warning progression
    if (bossWarning && !bossActive){
        const elapsed = timeElapsed - bossWarning.startTime;
        if (elapsed >= 2.0){
            // Spawn boss after 2 second warning
            spawnBoss();
            bossWarning = null;
            nextBossScore += bossScoreInterval;
        } else if (elapsed >= 1.0){
            // Last second - go RED
            bossWarning.warningPhase = 'red';
        }
    }
    updateBossUI();

    // combo timer decay
    comboTimer = Math.max(0, comboTimer - dt);
    if (comboTimer <= 0 && combo > 1){ combo = 1; updateComboUI(); }

    // auto-shoot
    shootTimer = Math.max(0, shootTimer - dt);
    if (document.getElementById('autoShootToggle')?.checked && running){ if (shootTimer <= 0) shootOnce(); }

    // shake decay
    screenShake = Math.max(0, screenShake - dt * 14.0);

    // update asteroids
    for (let i = asteroids.length - 1; i >= 0; i--){
        const a = asteroids[i];
        a.x += a.vx * dt; a.y += a.vy * dt;
        const dx = a.x - core.x; const dy = a.y - core.y; const dist = Math.hypot(dx, dy);
        // critical near-miss slow (auto-trigger) if an asteroid is very close OR if core is at 1 HP
        if (!bossActive && slowCooldown <= 0 && (dist < a.radius + core.r * 0.9 + 18 || coreHP <= 1)){
            // auto-trigger brief slow (dramatic)
            slowTimer = slowDuration; timeScale = 0.4; slowCooldown = slowCooldownDuration; startAudioIfNeeded(); playBeep(520,0.08); screenShake = Math.max(screenShake, 10);
        }
        if (dist < a.radius + core.r * 0.9){
            // hit core - Shield absorbs first hit
            if (shieldHP > 0){
                shieldHP--;
                explode(a.x, a.y, 8);
                startAudioIfNeeded(); playBeep(1200, 0.06);
                asteroids.splice(i,1);
            } else {
                const dmg = Math.max(1, Math.floor(a.radius / 8));
                coreHP = Math.max(0, coreHP - dmg);
                updateHPUI();
                // reset combo on core hit
                combo = 1; comboTimer = 0; updateComboUI();
                startAudioIfNeeded(); playExplosion();
                explode(a.x, a.y, 12 + Math.floor(a.radius/2));
                asteroids.splice(i,1);
                if (coreHP <= 0){ gameOver(); return; }
            }
        }
    }

    // update bullets and collisions
    for (let i = bullets.length - 1; i >= 0; i--){
        const b = bullets[i];
        b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
        // homing steering (gentle) if assigned a target
        if (b.homing && b.target){
            if (!asteroids.includes(b.target) || Math.hypot(b.x - b.target.x, b.y - b.target.y) > 800){ delete b.homing; delete b.target; }
            else {
                const tx = b.target.x - b.x, ty = b.target.y - b.y;
                const len = Math.hypot(tx,ty) || 1;
                const desiredVx = tx/len * b.speed, desiredVy = ty/len * b.speed;
                // stronger homing factor applied smoothly
                const h = Math.min(1, (b.homingFactor || 1) * dt);
                b.vx = b.vx * (1 - h) + desiredVx * h;
                b.vy = b.vy * (1 - h) + desiredVy * h;
                const l = Math.hypot(b.vx, b.vy) || 1;
                b.vx = b.vx / l * b.speed; b.vy = b.vy / l * b.speed;
            }
        }
        // if bullet expired or went offscreen without hitting -> miss
        if (b.life <= 0 || b.x < -50 || b.x > w + 50 || b.y < -50 || b.y > H + 50){
            // only break combo on manual misses (auto-shoot shouldn't punish)
            if (!b.hit && b.manual){
                combo = 1; comboTimer = 0; updateComboUI();
                // small negative feedback sound
                startAudioIfNeeded(); playBeep(320, 0.06);
                // small visual flash
                const chips = Array.from(document.querySelectorAll('.chip'));
                for (const c of chips){ if (c.textContent.includes('Combo')){ c.classList.add('combo-broken'); setTimeout(()=>c.classList.remove('combo-broken'), 500); break; } }
            }
            bullets.splice(i,1); continue;
        }
        // check power-up hits first
        for (let p = powerUps.length - 1; p >= 0; p--){
            const pu = powerUps[p];
            const pdx = pu.x - b.x, pdy = pu.y - b.y;
            if (pdx*pdx + pdy*pdy < 10*10){
                // collected
                if (pu.type === 'slow'){ slowCharges = Math.min(3, slowCharges + 1); updatePowerUI(); }
                powerUps.splice(p,1); bullets.splice(i,1); startAudioIfNeeded(); playBeep(1320,0.06);
                break;
            }
        }
        for (let j = asteroids.length - 1; j >= 0; j--){
            const a = asteroids[j];
            const dx = a.x - b.x; const dy = a.y - b.y;
            if (dx*dx + dy*dy < (a.radius + 2) ** 2){
                // hit asteroid
                a.hp = (a.hp || 1) - 1;
                if (a.hp > 0){
                    // small hit effect
                    startAudioIfNeeded(); playBeep(900, 0.04);
                    explode(b.x, b.y, 6);
                    bullets.splice(i,1);
                } else {
                    // destroyed
                    explode(a.x, a.y, 14 + Math.floor(a.radius/2));
                    startAudioIfNeeded(); playExplosion();
                    
                    // Explosion shot: create blast radius
                    if (explosionActive){
                        const blastRadius = 60;
                        for (let j2 = asteroids.length - 1; j2 >= 0; j2--){
                            const a2 = asteroids[j2];
                            if (a2 === a) continue;
                            const dx2 = a2.x - a.x, dy2 = a2.y - a.y;
                            if (dx2*dx2 + dy2*dy2 < blastRadius*blastRadius){
                                a2.hp = Math.max(0, (a2.hp || 1) - 1);
                                explode(a2.x, a2.y, 8);
                            }
                        }
                    }
                    
                    // big splits into smaller
                    if (a.type === 'big'){
                        for (let k=0;k<2;k++){
                            const ang = Math.random()*Math.PI*2;
                            const dist = a.radius;
                            const nx = a.x + Math.cos(ang)*dist;
                            const ny = a.y + Math.sin(ang)*dist;
                            const speed2 = 60 + Math.random()*120;
                            asteroids.push({ x: nx, y: ny, vx: Math.cos(ang)*speed2, vy: Math.sin(ang)*speed2, radius: Math.max(4, a.radius/2), hp:1, type:'small', sprite: a.sprite, scoreValue: 10 });
                        }
                    }
                    // combo: destroyed asteroid increases streak
                    combo = Math.min(999, combo + 1);
                    comboTimer = comboDuration;
                    const assistMultiplier = b.homing ? 0.9 : 1; // small penalty for assisted kills
                    const mult = Math.min(combo, 4); // cap multiplier for score to x4
                    score += (a.scoreValue || 10) * mult * assistMultiplier;
                    scoreEL.textContent = String(Math.floor(score));
                    updateComboUI();
                    
                    // Update challenges
                    totalAsteroidKills++;
                    localStorage.setItem('og_total_kills', String(totalAsteroidKills));
                    updateChallenge('kills', totalAsteroidKills);
                    updateChallenge('score', Math.floor(score));
                    updateChallenge('combo', combo);
                    
                    // Check if this is a boss before removal
                    const wasBoss = !!a.isBoss;
                    
                    // Grant XP for asteroid kill (with daily bonus)
                    let xpAmount = wasBoss ? 50 : 5;
                    if (dailyChallenge && dailyChallenge.type === 'xp_boost'){
                        xpAmount = Math.floor(xpAmount * dailyChallenge.bonus);
                    }
                    
                    if (wasBoss){
                        addXP(xpAmount);
                        const totalBosses = Number(localStorage.getItem('og_total_bosses') || 0) + 1;
                        localStorage.setItem('og_total_bosses', String(totalBosses));
                    } else {
                        addXP(xpAmount);
                        // Update daily challenge
                        if (dailyChallenge && dailyChallenge.type === 'kill_goal'){
                            dailyChallenge.progress = (dailyChallenge.progress || 0) + 1;
                            updateDailyChallengeUI();
                        }
                    }
                    
                    // Update progress goals
                    updateGoalsUI();
                    
                    // special FX for x2/x3/x4 - sounds disabled to avoid overlap with music
                    // if (combo === 2){ startAudioIfNeeded(); playBeep(1100, 0.06); }
                    // if (combo === 3){ startAudioIfNeeded(); playBeep(1200, 0.08); }
                    // small reward & flourish on milestones
                    if (combo % 5 === 0){ if (coreHP < coreMaxHP){ coreHP = Math.min(coreMaxHP, coreHP + 1); updateHPUI(); } }
                    asteroids.splice(j,1);
                    // Piercing shots: don't remove bullet
                    if (!piercingActive) bullets.splice(i,1);
                    if (wasBoss){
                        bossActive = false; bossObj = null; spawnTimer = 0.3; updateBossUI();
                        bossesKilled++; // Increment boss counter
                        updateBossCounter();
                        updateChallenge('bosses', bossesKilled);
                        asteroids.length = 0; // clear all remaining asteroids
                        grantRandomPowerUp(); // give player a power-up reward
                        startAudioIfNeeded(); 
                        // boss defeat sound disabled
                        console.log(`Boss defeated ‚Äî Power-Up granted! (Boss ${bossesKilled})`);
                    }
                break;
            }
        }
    }

    // update particles
    for (let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt;
        p.vx *= (1 - dt * 3.0); p.vy *= (1 - dt * 3.0);
        p.life -= dt; if (p.life <= 0) particles.splice(i,1);
    }

    // update power-ups
    for (let i = powerUps.length - 1; i >= 0; i--){
        const pu = powerUps[i];
        pu.x += (pu.vx || 0) * dt; pu.y += (pu.vy || 0) * dt; pu.life -= dt;
        pu.vx = (pu.vx || 0) * (1 - dt*1.0);
        pu.vy = (pu.vy || 0) * (1 - dt*1.0);
        if (pu.life <= 0) powerUps.splice(i,1);
    }

    // update active power-up timer
    if (activePowerUp && powerUpTimer > 0){
        powerUpTimer -= dt;
        if (powerUpTimer <= 0) deactivatePowerUp();
    }
    
    // time slow: use whichever is slower (emergency slow or power-up slow)
    if (slowTimer > 0){ slowTimer -= dt; if (slowTimer <= 0){ slowTimer = 0; } }
    
    // apply time slow multiplier based on active effects
    if (slowTimer > 0){
        timeScale = 0.4;
    } else if (activePowerUp && (activePowerUp === 'TIME_SLOW' || activePowerUp === 'PRECISION_MODE')){
        timeScale = timeSlowMultiplier;
    } else {
        timeScale = 1.0;
    }
    
    if (slowCooldown > 0) slowCooldown = Math.max(0, slowCooldown - dt);
    // update power UI
    updatePowerUI();
}
}


// call draw helpers after main draw
function postDraw(){
    if (!earthCanvas) initEarthCanvas();
    drawParticles(); drawBullets(); drawAsteroids(); drawPowerUps();
}

// --- Earth sprite renderer (pixel art) ---
function drawEarthSprite(){
    if (!earthCanvas) { console.warn('drawEarthSprite: earthCanvas nicht gefunden'); return; }
    const sctx = earthCanvas.getContext('2d');
    sctx.imageSmoothingEnabled = false;
    // debug: resize actual canvas pixel buffer to match CSS scaling for crisp pixels
    const rect = earthCanvas.getBoundingClientRect();
    const scale = Math.max(1, Math.round(rect.width / earthCanvas.width));
    if (earthCanvas.width !== Math.floor(rect.width / scale)){
        // upscale buffer to better match display
        earthCanvas.width = 16 * scale;
        earthCanvas.height = 16 * scale;
        // ensure image-rendering remains pixelated via CSS
    }

    const cols = 16, rows = 16;
    // simple 16x16 pixel map (approximation of the provided sprite)
    const map = [
        ['#001133','#001133','#0b325a','#0b325a','#0b325a','#0b325a','#001133','#001133','#001133','#001133','#0b325a','#0b325a','#0b325a','#0b325a','#001133','#001133'],
        ['#001133','#0b325a','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#0b325a','#0b325a','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#0b325a','#001133'],
        ['#0b325a','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#3da33d','#3da33d','#2e8bff','#2e8bff','#0b325a'],
        ['#0b325a','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#3da33d','#3da33d','#3da33d','#3da33d','#2e8bff','#2e8bff','#3da33d','#3da33d','#2e8bff','#0b325a'],
        ['#0b325a','#2e8bff','#2e8bff','#3da33d','#3da33d','#3da33d','#3da33d','#3da33d','#3da33d','#3da33d','#3da33d','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#0b325a'],
        ['#001133','#2e8bff','#2e8bff','#3da33d','#3da33d','#3da33d','#f1c40f','#f1c40f','#3da33d','#3da33d','#3da33d','#2e8bff','#2e8bff','#2e8bff','#0b325a','#001133'],
        ['#001133','#2e8bff','#2e8bff','#3da33d','#3da33d','#3da33d','#f1c40f','#f1c40f','#3da33d','#3da33d','#2e8bff','#2e8bff','#2e8bff','#0b325a','#001133','#001133'],
        ['#001133','#0b325a','#2e8bff','#2e8bff','#3da33d','#3da33d','#3da33d','#3da33d','#3da33d','#2e8bff','#2e8bff','#2e8bff','#0b325a','#001133','#001133','#001133'],
        ['#001133','#001133','#0b325a','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#2e8bff','#0b325a','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#0b325a','#0b325a','#0b325a','#0b325a','#2e8bff','#2e8bff','#0b325a','#0b325a','#001133','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#001133','#0b325a','#0b325a','#0b325a','#0b325a','#0b325a','#0b325a','#001133','#001133','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#001133','#001133','#0b325a','#0b325a','#0b325a','#0b325a','#001133','#001133','#001133','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#001133','#001133','#001133','#0b325a','#0b325a','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#001133','#001133','#001133','#001133','#0b325a','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133'],
        ['#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133','#001133']
    ];

    const pw = earthCanvas.width / cols;
    const ph = earthCanvas.height / rows;
    sctx.clearRect(0,0,earthCanvas.width,earthCanvas.height);
    for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
            sctx.fillStyle = map[y][x];
            sctx.fillRect(Math.floor(x*pw), Math.floor(y*ph), Math.ceil(pw), Math.ceil(ph));
        }
    }
    // apply tint if specified (simple multiply tint to the generated sprite)
    if (typeof earthTint === 'string' && earthTint){
        sctx.globalCompositeOperation = 'multiply';
        sctx.fillStyle = earthTint;
        sctx.fillRect(0,0,earthCanvas.width, earthCanvas.height);
        sctx.globalCompositeOperation = 'source-over';
    }
}

// --- Skins (colors) ---
let shipColor = '#ffffff';
let laserColor = '#ffd580';
let earthTint = '#2e8bff';
function hexToRGBA(hex, alpha){
    if (!hex) return 'rgba(255,255,255,' + (alpha||1) + ')';
    const h = hex.replace('#','');
    const bigint = parseInt(h,16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r},${g},${b},${alpha})`;
}
function applySkins(save = true){
    shipColor = (shipColorEl?.value) || shipColor;
    laserColor = (laserColorEl?.value) || laserColor;
    earthTint = (earthColorEl?.value) || earthTint;
    // persist
    if (save){ try{ localStorage.setItem('og_ship_color', shipColor); localStorage.setItem('og_laser_color', laserColor); localStorage.setItem('og_earth_color', earthTint);}catch(e){} }
    // re-render earth sprite with tint
    drawEarthSprite();
}


// --- Simple audio (procedural) ---
let audioCtx = null;
let musicInterval = null;
function startAudioIfNeeded(){
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        const savedVol = Number(localStorage.getItem('og_music_volume'));
        masterGain.gain.value = (!isNaN(savedVol) ? savedVol : 0.35);
        masterGain.connect(audioCtx.destination);
    }
    if (audioCtx.state === 'suspended') audioCtx.resume();
}
function setMusicVolume(v){
    const vol = Number(v);
    if (masterGain) masterGain.gain.value = vol;
    if (musicAudio) musicAudio.volume = vol;
    localStorage.setItem('og_music_volume', String(v));
    if (musicVolumeEl) musicVolumeEl.value = String(v);
}

// === BACKGROUND MUSIC (MP3 File) ===
let backgroundMusicPlaying = false;
let musicAudio = null;

function playBackgroundMusic(){
    if (backgroundMusicPlaying) return;
    backgroundMusicPlaying = true;
    
    if (!musicAudio) {
        musicAudio = new Audio('background-music-463062.mp3');
        musicAudio.loop = true;
        musicAudio.volume = 0.35;
    }
    
    startAudioIfNeeded();
    musicAudio.play().catch(e => console.warn('Music autoplay blocked:', e));
}

function stopBackgroundMusic(){
    backgroundMusicPlaying = false;
    if (musicAudio) {
        musicAudio.pause();
        musicAudio.currentTime = 0;
    }
}

function playTone(f, dur=0.12, type='square'){
    /* Disabled - MP3 music only */
}
function playMusicNote(freq, dur=0.5, type='sine', when){
    /* Disabled - MP3 music only */
}
function startMusic(){
    if (!audioCtx) startAudioIfNeeded();
    if (musicInterval) return;
    const seq = [330, 392, 440, 523];
    let i = 0;
    musicInterval = setInterval(()=>{
        const now = audioCtx.currentTime;
        // gentle pad
        playMusicNote(seq[i%seq.length], 0.8, 'triangle', now);
        // higher lead
        playMusicNote(seq[(i+1)%seq.length]*1.5, 0.38, 'sine', now + 0.06);
        // soft bass
        playMusicNote(seq[i%seq.length]/2, 0.5, 'sawtooth', now);
        i++;
    }, 600);
}
function stopMusic(){ if (musicInterval){ clearInterval(musicInterval); musicInterval = null; } }
function playBeep(freq=880, dur=0.06){ 
    /* Disabled - MP3 music only */ 
    return;
}
function playExplosion(){ if (!audioCtx || !masterGain) return; const bufferSize = audioCtx.sampleRate * 0.3; const b = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = b.getChannelData(0); for (let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize/8)); }
    const src = audioCtx.createBufferSource(); src.buffer = b; const g = audioCtx.createGain(); src.connect(g); g.connect(masterGain); g.gain.setValueAtTime(0.5, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6); src.start(); }

function loop(now) {
    if (!running) return;
    const rawDt = Math.min(0.033, (now-lastTime)/ 1000);
    // apply timeScale (for slow motion effects)
    const dt = rawDt * (timeScale || 1.0);
    lastTime = now;
    orbit.angle += orbit.dir * orbit.omega * orbitBoostMultiplier * dt;
    // Score only from destroying asteroids (no automatic time-based points)
    scoreEL.textContent = String(Math.floor(score));

    // Magnet effect: attract asteroids towards core
    if (magnetActive){
        for (const a of asteroids){
            const dx = core.x - a.x, dy = core.y - a.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 1){
                const pull = 120; // magnetisches Zugkraft
                a.vx += (dx / dist) * pull * dt;
                a.vy += (dy / dist) * pull * dt;
            }
        }
    }

    update(dt);
    draw();
    postDraw();
    requestAnimationFrame(loop);
}
canvas.addEventListener("pointerdown", (e) =>{
    if (!running) return;
    e.preventDefault();
    const mode = getGameplayMode();
    if (mode === 'A'){
        if (Date.now() - lastTouchTap < 250) return;
        tap();
        return;
    }
    if (mode === 'B'){
        orbit.dir = -1;
    }
}, {
    passive: false
});
canvas.addEventListener("pointerup", (e) =>{
    if (!running) return;
    e.preventDefault();
    if (getGameplayMode() === 'B') orbit.dir = 1;
}, { passive: false });
canvas.addEventListener("pointercancel", (e) =>{
    if (!running) return;
    e.preventDefault();
    if (getGameplayMode() === 'B') orbit.dir = 1;
}, { passive: false });
canvas.addEventListener("pointerleave", (e) =>{
    if (!running) return;
    if (getGameplayMode() === 'B') orbit.dir = 1;
});
if (startBtn){
    startBtn.style.cursor = 'pointer';
    startBtn.disabled = false;
    startBtn.setAttribute('aria-disabled','false');
    startBtn.addEventListener('click', (e)=>{ console.log('startBtn clicked'); e.preventDefault(); startGame(); });
    // listen to pointerup as well for more responsive mobile behavior
    startBtn.addEventListener('pointerup', (e)=>{ console.log('startBtn pointerup'); e.preventDefault(); e.stopPropagation(); startGame(); });
    startBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
} else { console.warn('startBtn not found when attaching handlers'); }

// Nuke button handler
const nukeBtn = document.getElementById('nukeButton');
if (nukeBtn){
    nukeBtn.style.cursor = 'pointer';
    nukeBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); activateNuke(); });
    nukeBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
}

// --- Initialization: earth sprite, settings and audio ---
// --- Background starfield (handled by animation at top) ---

(function initUI(){
    console.log('initUI: starte UI-Initialisierung');
    // ensure default asteroid sprites exist and draw static earth once
    createDefaultAsteroidSprites();
    drawEarthSprite();
    updateComboUI();
    // starfield already initialized at top of script
    
    // draw pixel logo into overlay
    function drawLogo(){
        try{
            const logo = document.getElementById('logoCanvas'); if (!logo) return;
            const lctx = logo.getContext('2d');
            // small offscreen render to create pixelated style
            const small = document.createElement('canvas'); small.width = 128; small.height = 20; const sctx = small.getContext('2d');
            sctx.clearRect(0,0,small.width,small.height);
            sctx.fillStyle = '#ffffff'; sctx.font = 'bold 10px monospace'; sctx.textBaseline = 'middle';
            const txt = 'ORBIT GUARDIAN';
            const tw = sctx.measureText(txt).width;
            sctx.fillText(txt, Math.floor((small.width - tw)/2), Math.floor(small.height/2));
            // scale up with nearest-neighbor
            lctx.imageSmoothingEnabled = false; lctx.clearRect(0,0,logo.width, logo.height);
            lctx.drawImage(small, 0, 0, logo.width, logo.height);
        }catch(e){ console.warn('drawLogo err', e); }
    }
    drawLogo();
    window.addEventListener('resize', drawLogo);

    // overlay footer values
    try{ 
        const ob = document.getElementById('overlayBest'); 
        if (ob) ob.textContent = String(best); 

        const savedMode = localStorage.getItem('og_gameplay_mode');
        if (savedMode){
            const savedRadio = document.querySelector(`input[name="mode"][value="${savedMode}"]`);
            if (savedRadio) savedRadio.checked = true;
            setGameplayMode(savedMode);
        }

        const om = document.getElementById('overlayMode'); 
        if (om) om.textContent = document.querySelector('input[name="mode"]:checked')?.value || 'A';

        // update overlay mode whenever radios change
        const radios = document.querySelectorAll('input[name="mode"]'); 
        radios.forEach(r=> r.addEventListener('change', ()=>{ 
            const current = document.querySelector('input[name="mode"]:checked')?.value || 'A';
            setGameplayMode(current);
            const om2 = document.getElementById('overlayMode'); 
            if (om2) om2.textContent = current; 
        }));
    }catch(e){}


    // load skins
    try{ shipColor = localStorage.getItem('og_ship_color') || shipColor; laserColor = localStorage.getItem('og_laser_color') || laserColor; earthTint = localStorage.getItem('og_earth_color') || earthTint; }catch(e){}
    if (shipColorEl) shipColorEl.value = shipColor; if (laserColorEl) laserColorEl.value = laserColor; if (earthColorEl) earthColorEl.value = earthTint;
    applySkins(false);
    shipColorEl?.addEventListener('input', ()=> applySkins(true));
    laserColorEl?.addEventListener('input', ()=> applySkins(true));
    earthColorEl?.addEventListener('input', ()=> applySkins(true));

    // restore music preference
    const musicPref = localStorage.getItem('og_music');
    console.log('initUI: gefunden musicPref=', musicPref, 'musicToggleExists=', !!musicToggle);
    if (musicToggle && musicPref === 'false') { musicToggle.checked = false; }

    // Aim assist is always on
    if (aimAssistToggle){
        aimAssistToggle.checked = true;
        aimAssistToggle.disabled = true;
    }

    // open overlay by default (initial screen)
    overlay.classList.add('open');

    // settings button handlers
    if (settingsBtn && settingsModel){
        settingsBtn.addEventListener('click', ()=>{ 
            settingsModel.classList.add('open'); 
            drawEarthSprite(); 
            renderSkinMenu(); // Show skins when opening settings
            updateProfileStats(); // Update profile stats
        });
    }
    updateModeUI();
    
    // Stats toggle button
    const toggleStatsBtn = document.getElementById('toggleStatsBtn');
    const startStatsPanel = document.getElementById('startStatsPanel');
    if (toggleStatsBtn && startStatsPanel) {
        startStatsPanel.classList.remove('is-open');
        startStatsPanel.setAttribute('aria-hidden', 'true');
        startStatsPanel.hidden = true;
        startStatsPanel.style.setProperty('display', 'none', 'important');
        toggleStatsBtn.textContent = 'üìä STATS';
        toggleStatsBtn.addEventListener('click', () => {
            if (!startStatsPanel.classList.contains('is-open')) {
                startStatsPanel.classList.add('is-open');
                startStatsPanel.setAttribute('aria-hidden', 'false');
                startStatsPanel.hidden = false;
                startStatsPanel.style.setProperty('display', 'grid', 'important');
                toggleStatsBtn.textContent = 'üìä STATS ‚ñ≤';
            } else {
                startStatsPanel.classList.remove('is-open');
                startStatsPanel.setAttribute('aria-hidden', 'true');
                startStatsPanel.hidden = true;
                startStatsPanel.style.setProperty('display', 'none', 'important');
                toggleStatsBtn.textContent = 'üìä STATS';
            }
        });
    }
    closeStartStatsPanel();
    setTimeout(closeStartStatsPanel, 0);
    setTimeout(closeStartStatsPanel, 250);
    
    // Stats Card Modal Handlers
    const leaderboardModal = document.getElementById('leaderboardModal');
    const rivalModal = document.getElementById('rivalModal');
    const sessionModal = document.getElementById('sessionModal');
    const dailyModal = document.getElementById('dailyModal');
    
    const rankCard = document.getElementById('rankCard');
    const rivalCard = document.getElementById('rivalCard');
    const sessionCard = document.getElementById('sessionCard');
    const dailyCard = document.getElementById('dailyCard');
    
    // Open Modals
    if (rankCard) {
        rankCard.addEventListener('click', () => {
            leaderboardModal.setAttribute('aria-hidden', 'false');
            generateLeaderboard();
        });
    }
    
    if (rivalCard) {
        rivalCard.addEventListener('click', () => {
            rivalModal.setAttribute('aria-hidden', 'false');
            generateRivalInfo();
        });
    }
    
    if (sessionCard) {
        sessionCard.addEventListener('click', () => {
            sessionModal.setAttribute('aria-hidden', 'false');
            generateSessionTasks();
        });
    }
    
    if (dailyCard) {
        dailyCard.addEventListener('click', () => {
            dailyModal.setAttribute('aria-hidden', 'false');
            generateDailyTasks();
        });
    }
    
    // Close Modals
    const closeLeaderboard = document.getElementById('closeLeaderboard');
    const closeRival = document.getElementById('closeRival');
    const closeSession = document.getElementById('closeSession');
    const closeDaily = document.getElementById('closeDaily');
    
    if (closeLeaderboard) {
        closeLeaderboard.addEventListener('click', () => {
            leaderboardModal.setAttribute('aria-hidden', 'true');
        });
    }
    
    if (closeRival) {
        closeRival.addEventListener('click', () => {
            rivalModal.setAttribute('aria-hidden', 'true');
        });
    }
    
    if (closeSession) {
        closeSession.addEventListener('click', () => {
            sessionModal.setAttribute('aria-hidden', 'true');
        });
    }
    
    if (closeDaily) {
        closeDaily.addEventListener('click', () => {
            dailyModal.setAttribute('aria-hidden', 'true');
        });
    }
    
    // Generate Leaderboard (Top 50)
    function generateLeaderboard() {
        const table = document.getElementById('leaderboardTable');
        if (!table) return;
        
        table.innerHTML = '';
        
        // Generate 50 players with scores
        const players = [];
        for (let i = 0; i < 50; i++) {
            const playerScore = Math.max(0, Math.floor(Math.random() * 10000) - i * 50);
            const playerName = `Player${i + 1}`;
            players.push({ name: playerName, score: playerScore, isPlayer: i === 5 }); // Player is rank 6
        }
        
        // Sort by score
        players.sort((a, b) => b.score - a.score);
        
        // Create rows
        players.forEach((player, index) => {
            const row = document.createElement('div');
            row.className = 'leaderboard-row' + (player.isPlayer ? ' player-row' : '');
            
            const rank = document.createElement('div');
            rank.className = 'leaderboard-rank';
            rank.textContent = `#${index + 1}`;
            
            const name = document.createElement('div');
            name.className = 'leaderboard-name';
            name.textContent = player.isPlayer ? 'DU' : player.name;
            
            const scoreEl = document.createElement('div');
            scoreEl.className = 'leaderboard-score';
            scoreEl.textContent = player.score.toLocaleString();
            
            row.appendChild(rank);
            row.appendChild(name);
            row.appendChild(scoreEl);
            
            table.appendChild(row);
        });
    }
    
    // Generate Rival Info
    function generateRivalInfo() {
        const rivalInfo = document.getElementById('rivalInfo');
        if (!rivalInfo) return;
        
        rivalInfo.innerHTML = `
            <div class="rival-avatar">‚öîÔ∏è</div>
            <div class="rival-name">Player42</div>
            <p style="color: rgba(255,255,255,0.7); font-size: 14px;">Dein aktueller Rivale im Kampf um die Rangliste!</p>
            <div class="rival-stats">
                <div class="rival-stat-item">
                    <div class="rival-stat-label">RANG</div>
                    <div class="rival-stat-value">#5</div>
                </div>
                <div class="rival-stat-item">
                    <div class="rival-stat-label">SCORE</div>
                    <div class="rival-stat-value">${typeof rivalBot !== 'undefined' && rivalBot ? rivalBot.score : '2,450'}</div>
                </div>
                <div class="rival-stat-item">
                    <div class="rival-stat-label">LEVEL</div>
                    <div class="rival-stat-value">${typeof playerLevel !== 'undefined' ? playerLevel + 1 : '3'}</div>
                </div>
                <div class="rival-stat-item">
                    <div class="rival-stat-label">VORSPRUNG</div>
                    <div class="rival-stat-value">+${Math.floor(Math.random() * 500)}</div>
                </div>
            </div>
        `;
    }
    
    // Generate Session Tasks
    function generateSessionTasks() {
        const tasksList = document.getElementById('sessionTasks');
        if (!tasksList) return;
        
        const tasks = [
            { title: 'Spiele 5 Runden', reward: '+100 XP', progress: 3, max: 5 },
            { title: 'Erreiche Score 1000', reward: '+200 XP', progress: 450, max: 1000 },
            { title: 'Besiege 10 Asteroiden', reward: '+50 XP', progress: 7, max: 10 },
            { title: '√úberlebe 60 Sekunden', reward: '+150 XP', progress: 0, max: 60 }
        ];
        
        tasksList.innerHTML = tasks.map(task => {
            const percentage = (task.progress / task.max) * 100;
            const completed = task.progress >= task.max;
            
            return `
                <div class="task-item ${completed ? 'completed' : ''}">
                    <div class="task-header">
                        <div class="task-title">${completed ? '‚úì ' : ''}${task.title}</div>
                        <div class="task-reward">${task.reward}</div>
                    </div>
                    <div class="task-progress">${task.progress} / ${task.max}</div>
                    <div class="task-progress-bar">
                        <div class="task-progress-fill" style="width: ${percentage}%"></div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    // Generate Daily Tasks
    function generateDailyTasks() {
        const tasksList = document.getElementById('dailyTasks');
        if (!tasksList) return;
        
        const tasks = [
            { title: 'T√§gliche Anmeldung', reward: '+50 XP', progress: 1, max: 1 },
            { title: 'Erreiche Level 3', reward: '+300 XP', progress: typeof playerLevel !== 'undefined' ? playerLevel : 1, max: 3 },
            { title: 'Nutze 5x Zeitlupe', reward: '+100 XP', progress: 2, max: 5 },
            { title: 'Besiege einen Boss', reward: '+500 XP', progress: 0, max: 1 }
        ];
        
        tasksList.innerHTML = tasks.map(task => {
            const percentage = (task.progress / task.max) * 100;
            const completed = task.progress >= task.max;
            
            return `
                <div class="task-item ${completed ? 'completed' : ''}">
                    <div class="task-header">
                        <div class="task-title">${completed ? '‚úì ' : ''}${task.title}</div>
                        <div class="task-reward">${task.reward}</div>
                    </div>
                    <div class="task-progress">${task.progress} / ${task.max}</div>
                    <div class="task-progress-bar">
                        <div class="task-progress-fill" style="width: ${percentage}%"></div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    const settingsHudBtn = document.getElementById('settingsHudBtn');
    if (settingsHudBtn){ settingsHudBtn.addEventListener('click', ()=>{ settingsModel.classList.add('open'); settingsModel.setAttribute('aria-hidden','false'); drawEarthSprite(); }); }
    // Start overlay: animated start and robust handlers (Start button + overlay 'start anywhere' toggle)
    const startFullOverlayBtn = document.getElementById('startFullOverlayBtn');
    function showStartDebug(msg){
        try{
            const dbg = document.getElementById('startDebug');
            if (dbg){ dbg.textContent = msg; dbg.style.opacity = '1'; setTimeout(()=> dbg.style.opacity = '0', 1600); }
        }catch(e){ console.log('debug show err', e); }
    }
    function triggerStartAnimation(){
        if (running) return; console.log('start animation trigger'); showStartDebug('Starte...'); overlay.classList.add('closing'); overlay.classList.remove('open');
        // brief delay for UI animation then start game
        setTimeout(()=>{ overlay.classList.add('hidden'); overlay.classList.remove('closing'); startGame(); }, 380);
    }
    if (overlay){
        overlay.addEventListener('pointerup', (e)=>{
            if (running) return;
            const startBtnEl = e.target.closest && e.target.closest('#startBtn');
            if (startBtnEl){ e.preventDefault(); e.stopPropagation(); triggerStartAnimation(); return; }
            // if enabled, clicking outside panel will start
            if (overlay.dataset.startAnywhere === 'true' && !e.target.closest('.start-panel')){ triggerStartAnimation(); }
        });
    }
    if (startFullOverlayBtn){
        startFullOverlayBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); overlay.dataset.startAnywhere = overlay.dataset.startAnywhere === 'true' ? 'false' : 'true'; startFullOverlayBtn.textContent = overlay.dataset.startAnywhere === 'true' ? 'START ANYWHERE ‚úì' : 'START ANYWHERE'; showStartDebug(overlay.dataset.startAnywhere === 'true' ? 'Start √ºberall aktiviert' : 'Start √ºberall deaktiviert'); });
    }



    // ensure start button uses the animated trigger
    if (startBtn){
        startBtn.style.cursor = 'pointer'; startBtn.disabled = false; startBtn.setAttribute('aria-disabled','false');
        // extra instrumented handler: visual + console feedback to debug unresponsive clicks
        startBtn.addEventListener('click', (e)=>{ console.log('startBtn clicked'); e.preventDefault(); startBtn.style.transform = 'scale(.98)'; playBeep(1200,0.06); setTimeout(()=> startBtn.style.transform = '', 120); triggerStartAnimation(); });
        startBtn.addEventListener('pointerup', (e)=>{ console.log('startBtn pointerup'); e.preventDefault(); e.stopPropagation(); triggerStartAnimation(); });
        startBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
    }

    // keyboard support: Enter or Space to start when overlay is open
    window.addEventListener('keydown', (e)=>{ if (!running && (e.key === 'Enter' || e.key === ' ')) { if (overlay && !overlay.classList.contains('hidden')) triggerStartAnimation(); } });
    
    // Settings Tab System
    const settingsTabs = document.querySelectorAll('.settings-tab');
    const settingsContents = document.querySelectorAll('.settings-content');
    
    settingsTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.tab;
            
            // Remove active from all tabs and contents
            settingsTabs.forEach(t => t.classList.remove('active'));
            settingsContents.forEach(c => c.classList.remove('active'));
            
            // Add active to clicked tab and corresponding content
            tab.classList.add('active');
            const targetContent = document.querySelector(`[data-content="${targetTab}"]`);
            if (targetContent) targetContent.classList.add('active');
            
            // Update profile stats when profile tab is opened
            if (targetTab === 'profile') updateProfileStats();
        });
    });
    
    // Update profile stats
    function updateProfileStats(){
        const profileLevel = document.getElementById('profileLevel');
        const profileXP = document.getElementById('profileXP');
        const profileHighscore = document.getElementById('profileHighscore');
        const profileKills = document.getElementById('profileKills');
        const profileBosses = document.getElementById('profileBosses');
        
        if (profileLevel) profileLevel.textContent = playerLevel;
        if (profileXP) profileXP.textContent = playerXP.toLocaleString();
        if (profileHighscore) profileHighscore.textContent = best.toLocaleString();
        if (profileKills) profileKills.textContent = totalAsteroidKills.toLocaleString();
        if (profileBosses) profileBosses.textContent = (localStorage.getItem('og_total_bosses') || 0);
    }
    
    // Volume slider value display AND real-time volume change
    const volumeValue = document.getElementById('volumeValue');
    if (musicVolumeEl && volumeValue){
        volumeValue.textContent = Math.round(musicVolumeEl.value * 100) + '%';
        musicVolumeEl.addEventListener('input', () => {
            const newVolume = parseFloat(musicVolumeEl.value);
            volumeValue.textContent = Math.round(newVolume * 100) + '%';
            // Change volume in real-time
            if (musicAudio){
                musicAudio.volume = newVolume;
            }
        });
    }
    
    // Reset progress button
    const resetProgressBtn = document.getElementById('resetProgressBtn');
    if (resetProgressBtn){
        resetProgressBtn.addEventListener('click', () => {
            if (confirm('‚ö†Ô∏è Wirklich allen Fortschritt l√∂schen? (Level, XP, Highscore, Kills)')){
                localStorage.removeItem('og_xp');
                localStorage.removeItem('og_level');
                localStorage.removeItem('og_total_kills');
                localStorage.removeItem('og_total_bosses');
                localStorage.removeItem('best_orbit_guardian');
                localStorage.removeItem('og_leaderboard');
                alert('‚úÖ Fortschritt wurde zur√ºckgesetzt. Seite wird neu geladen.');
                location.reload();
            }
        });
    }
    
    // Settings buttons
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    
    function saveAllSettings(){
        // Save music settings
        if (musicToggle){
            localStorage.setItem('og_music', musicToggle.checked ? 'true' : 'false');
            if (musicToggle.checked){ startAudioIfNeeded(); startMusic(); } else { stopMusic(); }
        }
        // Save gameplay mode
        const selectedMode = document.querySelector('input[name="mode"]:checked')?.value || 'A';
        setGameplayMode(selectedMode);
        // Save volume
        if (musicVolumeEl){
            localStorage.setItem('og_volume', musicVolumeEl.value);
            if (musicAudio) musicAudio.volume = parseFloat(musicVolumeEl.value);
        }
        // Force aim assist always on
        isAimAssistEnabled();
        settingsModel.classList.remove('open');
    }
    
    // Close button (X)
    if (closeSettingsBtn){ 
        closeSettingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            saveAllSettings();
        }); 
    }
    
    // Save button
    if (saveSettingsBtn){
        saveSettingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            saveAllSettings();
        });
    }

    // Load music toggle from settings
    if (musicToggle){
        musicToggle.addEventListener('change', ()=>{
            localStorage.setItem('og_music', musicToggle.checked ? 'true' : 'false');
            if (musicToggle.checked){ startAudioIfNeeded(); startMusic(); } else { stopMusic(); }
        });
    }

    // volume control
    const savedVol = Number(localStorage.getItem('og_music_volume'));
    if (musicVolumeEl) { musicVolumeEl.value = !isNaN(savedVol) ? String(savedVol) : '0.35'; musicVolumeEl.addEventListener('input', ()=> setMusicVolume(musicVolumeEl.value)); }

    // input handlers
    if (dirBtn) dirBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); handleDirectionInputStart(); }, { passive: false });
    if (dirBtn) dirBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); handleDirectionInputEnd(); }, { passive: false });
    if (dirBtn) dirBtn.addEventListener('pointercancel', (e)=>{ e.preventDefault(); handleDirectionInputEnd(); }, { passive: false });
    if (dirBtn) dirBtn.addEventListener('pointerleave', (e)=>{ e.preventDefault(); handleDirectionInputEnd(); }, { passive: false });
    if (shootBtn) shootBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); shootOnce(true); }, { passive: false });
    const tapLayer = document.getElementById('tapLayer');
    if (tapLayer){
        tapLayer.addEventListener('pointerdown', (e)=>{
            if (!running) return;
            if (getGameplayMode() !== 'A') return;
            e.preventDefault();
            tap();
        }, { passive: false });
        tapLayer.addEventListener('touchstart', (e)=>{
            if (!running) return;
            if (getGameplayMode() !== 'A') return;
            e.preventDefault();
            tap();
        }, { passive: false });
    }
    window.addEventListener('keydown', (e)=>{ 
        if (!running) return; 
        if (e.code === 'Space'){ 
            const mode = getGameplayMode();
            if (mode === 'B'){
                if (!e.repeat) handleDirectionInputStart();
            } else {
                handleDirectionInputStart();
            }
        }
        if (e.code === 'KeyF') shootOnce(true); 
        if (e.code === 'KeyQ'){ // manual slow
            if (slowCharges > 0 && slowTimer <= 0){ slowCharges = Math.max(0, slowCharges - 1); slowTimer = slowDuration; timeScale = 0.4; slowCooldown = slowCooldownDuration; updatePowerUI(); screenShake = Math.max(screenShake, 12); }
        } 
    });
    window.addEventListener('keyup', (e)=>{
        if (!running) return;
        if (e.code === 'Space') handleDirectionInputEnd();
    });

    // Mode A: tap anywhere (except UI) to change direction
    window.addEventListener('pointerdown', (e)=>{
        if (!running) return;
        if (getGameplayMode() !== 'A') return;
        const target = e.target;
        if (shouldIgnoreGlobalTap(target)) return;
        const now = Date.now();
        if (now - lastGlobalTap < 200) return;
        lastGlobalTap = now;
        tap();
    }, { passive: false, capture: true });

    window.addEventListener('touchstart', (e)=>{
        if (!running) return;
        if (getGameplayMode() !== 'A') return;
        const target = e.target;
        if (shouldIgnoreGlobalTap(target)) return;
        const now = Date.now();
        if (now - lastGlobalTap < 200) return;
        lastGlobalTap = now;
        e.preventDefault();
        e.stopPropagation();
        tap();
    }, { passive: false, capture: true });
    
    // Enhanced touch controls for mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let hasMoved = false;
    
    document.addEventListener('touchstart', (e) => {
        if (!running) return;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
        hasMoved = false;
        const mode = getGameplayMode();
        if (mode === 'B'){
            orbit.dir = -1;
        }
    }, { passive: true });
    
    document.addEventListener('touchmove', (e) => {
        if (!running) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const deltaX = Math.abs(touchX - touchStartX);
        const deltaY = Math.abs(touchY - touchStartY);
        
        if (deltaX > 10 || deltaY > 10) {
            hasMoved = true;
        }
    }, { passive: true });
    
    // Simple tap controls
    document.addEventListener('touchend', (e) => {
        if (!running) return;
        
        const now = Date.now();
        const touchDuration = now - touchStartTime;
        const mode = getGameplayMode();
        if (mode === 'B') orbit.dir = 1;
        
        // Mode A handled on touchstart
        if (mode === 'A') return;
    }, { passive: true });

    document.addEventListener('touchcancel', (e)=>{
        if (getGameplayMode() === 'B') orbit.dir = 1;
    }, { passive: true });

    // ===== MOBILE INFO PANEL =====
    (function initMobileInfoPanel() {
        const mobileInfoPanel = document.getElementById('mobileInfoPanel');
        const closeMobileInfoBtn = document.getElementById('closeMobileInfoBtn');
        const mobileInfoTabs = document.querySelectorAll('.mobile-info-tab');
        const mobileInfoSections = document.querySelectorAll('.mobile-info-section');
        
        // Close Button
        if (closeMobileInfoBtn && mobileInfoPanel) {
            closeMobileInfoBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                mobileInfoPanel.setAttribute('aria-hidden', 'true');
            });
        }
        
        // Tab Navigation
        mobileInfoTabs.forEach(tab => {
            tab.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const tabName = tab.dataset.tab;
                if (!tabName) return;
                
                // Remove active from all
                mobileInfoTabs.forEach(t => t.classList.remove('active'));
                mobileInfoSections.forEach(s => s.classList.remove('active'));
                
                // Add active to clicked
                tab.classList.add('active');
                const section = document.getElementById(`tab-${tabName}`);
                if (section) section.classList.add('active');
            });
        });
    })();
    
    // Update mobile HUD elements during gameplay
    function updateMobileHUD() {
        try {
            // Update level display
            if (levelDisplay && typeof playerLevel !== 'undefined') {
                levelDisplay.textContent = playerLevel;
            }
            
            if (window.isMobileScreen) {
                if (typeof score !== 'undefined') {
                    document.getElementById('mobileScore').textContent = score;
                }
                if (typeof playerLevel !== 'undefined') {
                    document.getElementById('mobileLevel').textContent = `Lv ${playerLevel}`;
                }
                if (typeof highscore !== 'undefined') {
                    document.getElementById('mobileBest').textContent = `Best: ${highscore}`;
                }
                
                // Update mobile challenge panel
                const challengeTitle = document.getElementById('mobileChallengeTitle');
                const mobileChallengeText = document.getElementById('mobileChallengeText');
                const mobileChallengeFill = document.getElementById('mobileChallengeFill');
                
                if (typeof currentChallenge !== 'undefined' && currentChallenge && challengeTitle) {
                    challengeTitle.textContent = currentChallenge.name || '-';
                    const percent = Math.min(100, (currentChallenge.current / currentChallenge.goal) * 100);
                    if (mobileChallengeFill) mobileChallengeFill.style.width = percent + '%';
                    if (mobileChallengeText) mobileChallengeText.textContent = `${currentChallenge.current} / ${currentChallenge.goal}`;
                }
                
                // Update mobile daily challenge
                const mobileDailyChallenge = document.getElementById('mobileDailyChallenge');
                if (typeof getDailyChallenge !== 'undefined' && mobileDailyChallenge) {
                    const dailyChall = getDailyChallenge();
                    if (dailyChall) {
                        mobileDailyChallenge.textContent = dailyChall.name || '-';
                    }
                }
                
                // Update mobile goals
                const mobileProgressGoals = document.getElementById('mobileProgressGoals');
                if (typeof getNextGoals !== 'undefined' && mobileProgressGoals) {
                    const goals = getNextGoals();
                    mobileProgressGoals.innerHTML = goals.map(g => `<div>${g}</div>`).join('');
                }
                
                // Update mobile galaxy rank
                const mobileRankInfo = document.getElementById('mobileRankInfo');
                const mobileRivalInfo = document.getElementById('mobileRivalInfo');
                
                if (mobileRankInfo && typeof leaderboard !== 'undefined') {
                    const playerRank = leaderboard.findIndex(e => !e.isBot) + 1;
                    const rankValue = mobileRankInfo.querySelector('.rank-value');
                    if (rankValue) rankValue.textContent = `#${playerRank}`;
                }
                
                if (mobileRivalInfo) {
                    if (typeof rivalBot !== 'undefined' && rivalBot !== null) {
                        const rivalValue = mobileRivalInfo.querySelector('.rival-value');
                        if (rivalValue) rivalValue.textContent = `${rivalBot.name} (${rivalBot.score})`;
                    } else {
                        const rivalValue = mobileRivalInfo.querySelector('.rival-value');
                        if (rivalValue) rivalValue.textContent = `-`;
                    }
                }
            }
            
            // Update start screen stats
            updateStartStats();
        } catch(e) {
            console.log('updateMobileHUD error:', e);
        }
    }
    
    // Update start screen stats
    function updateStartStats() {
        try {
            const startRankInfo = document.getElementById('startRankInfo');
            const startRivalInfo = document.getElementById('startRivalInfo');
            const startSessionInfo = document.getElementById('startSessionInfo');
            const startDailyInfo = document.getElementById('startDailyInfo');
            
            if (startRankInfo && typeof leaderboard !== 'undefined') {
                const playerRank = leaderboard.findIndex(e => !e.isBot) + 1;
                startRankInfo.textContent = playerRank > 0 ? `#${playerRank}` : '-';
            }
            
            if (startRivalInfo) {
                if (typeof rivalBot !== 'undefined' && rivalBot !== null) {
                    startRivalInfo.textContent = rivalBot.name || '-';
                } else {
                    startRivalInfo.textContent = '-';
                }
            }
            
            if (startSessionInfo) {
                if (typeof currentChallenge !== 'undefined' && currentChallenge !== null) {
                    const percent = Math.min(100, (currentChallenge.current / currentChallenge.goal) * 100);
                    startSessionInfo.textContent = `${Math.round(percent)}%`;
                } else {
                    startSessionInfo.textContent = '-';
                }
            }
            
            if (startDailyInfo) {
                if (typeof getDailyChallenge !== 'undefined') {
                    const dailyChall = getDailyChallenge();
                    if (dailyChall && dailyChall.name) {
                        // Extract bonus percentage from challenge name
                        const match = dailyChall.name.match(/\+(\d+)%/);
                        startDailyInfo.textContent = match ? `+${match[1]}%` : '‚úì';
                    } else {
                        startDailyInfo.textContent = '-';
                    }
                } else {
                    startDailyInfo.textContent = '-';
                }
            }
        } catch(e) {
            console.log('updateStartStats error:', e);
        }
    }
    
    // Call update on game loop
    setInterval(updateMobileHUD, 100);

    // user gesture to resume/start audio (required by browsers)
    const gestureStart = ()=>{
        console.log('gestureStart: Benutzer-Geste erkannt ‚Äî Audio wird initialisiert');
        startAudioIfNeeded();
        if (musicToggle && musicToggle.checked) startMusic();
        window.removeEventListener('pointerdown', gestureStart);
    };
    window.addEventListener('pointerdown', gestureStart);
    
    // Initialize leaderboard and challenge systems
    initLeaderboard();
    initSessionChallenge();
    
    // Ensure leaderboard is visible
    if (leaderboardPanel){
        leaderboardPanel.style.display = 'block';
        leaderboardPanel.style.visibility = 'visible';
    }
    
    renderLeaderboard();
    startBotUpdates(); // Start autonomous bot updates
    
    // Initialize skin system
    unlockSkins();
    renderSkinMenu();
    updateXPUI();
    updateGoalsUI();
    updateDailyChallengeUI();
    
    // responsiveness: redraw earth on resize
    window.addEventListener('resize', ()=>{
        // resize main canvas logical buffer to match layout
        const newW = canvas.clientWidth;
        const newH = canvas.clientHeight;
        if (canvas.width !== newW || canvas.height !== newH){
            canvas.width = newW; canvas.height = newH;
        }
        // redraw earth sprite buffer to match CSS size
        drawEarthSprite();
        draw();
    });


})();
</script>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').catch(() => {});
        });
    }
</script>
</body>
</html> 